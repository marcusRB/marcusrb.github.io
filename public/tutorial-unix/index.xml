<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Unix, Shell y Bash | MarcusRB | consultor &amp; profesor data analytics • AI • Big Data</title>
    <link>https://www.marcusrb.com/tutorial-unix/</link>
      <atom:link href="https://www.marcusrb.com/tutorial-unix/index.xml" rel="self" type="application/rss+xml" />
    <description>Tutorial de Unix, Shell y Bash</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>es-ES</language><copyright>© 2021</copyright><lastBuildDate>Wed, 24 Jun 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://www.marcusrb.com/img/icon-192.png</url>
      <title>Tutorial de Unix, Shell y Bash</title>
      <link>https://www.marcusrb.com/tutorial-unix/</link>
    </image>
    
    <item>
      <title>Administracion de software 2</title>
      <link>https://www.marcusrb.com/unix/11-administracion-software-2/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/11-administracion-software-2/</guid>
      <description>

&lt;h1 id=&#34;administracion-de-software-2&#34;&gt;Administracion de software 2&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#estndar-de-jerarqua-del-sistema-de-archivos&#34; target=&#34;_blank&#34;&gt;Estándar de jerarquía del sistema de archivos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instalando programas

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#readme-e-install&#34; target=&#34;_blank&#34;&gt;README e INSTALL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#instalando-programas-compilados&#34; target=&#34;_blank&#34;&gt;Instalando programas compilados&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#instalando-un-programa-desde-el-cdigo-fuente&#34; target=&#34;_blank&#34;&gt;Instalando un programa desde el código fuente&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instalando programas Java.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#java-libres&#34; target=&#34;_blank&#34;&gt;Java libres&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#java-de-oracle&#34; target=&#34;_blank&#34;&gt;Java de oracle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#ejecutar-programas-java&#34; target=&#34;_blank&#34;&gt;Ejecutar programas java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#virtualenv&#34; target=&#34;_blank&#34;&gt;Virtualenv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#r&#34; target=&#34;_blank&#34;&gt;R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software2.html#programas-que-se-pueden-instalar&#34; target=&#34;_blank&#34;&gt;Programas que se pueden instalar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;estándar-de-jerarquía-del-sistema-de-archivos&#34;&gt;Estándar de jerarquía del sistema de archivos&lt;/h2&gt;

&lt;p&gt;Antes de instalar software no administrado por nuestra distribución  conviene que tengamos una idea de como se organiza el sistema de  archivos en Linux para que entendamos dónde se instala el software. Linux sigue una norma estándar llamada &lt;a href=&#34;http://es.wikipedia.org/wiki/Filesystem_Hierarchy_Standard&#34; target=&#34;_blank&#34;&gt;Estándar de jerarquía del sistema de archivos&lt;/a&gt; que define los directorios del sistema y la localización de los distintos tipos de archivos.&lt;/p&gt;

&lt;p&gt;En Unix todos los archivos y directorios aparecen bajo el directorio  raíz (/). Es habitual que dentro del directorio raíz existen tres jerarquías en  las que se distribuyen los archivos y directorios de los programas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;/,&lt;strong&gt;jerarquía primaria&lt;/strong&gt;. De ella cuelgan el resto de jerarquías. Los archivos incluidos directamente en esta jerarquía son  sólo los esenciales para el sistema, como por ejemplo los comandos: &lt;em&gt;cp&lt;/em&gt;, &lt;em&gt;ls&lt;/em&gt; o &lt;em&gt;mkdir&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;/usr/, &lt;strong&gt;jerarquía secundaria&lt;/strong&gt;. Contiene la mayoría  de aplicaciones del sistema. En las distribuciones Linux es la jerarquía en las que los programas de uso común son instalados, como por ejemplo  el LibreOffice o el entorno de usuario Gnome.&lt;/li&gt;
&lt;li&gt;/usr/local/, &lt;strong&gt;jerarquía terciaria&lt;/strong&gt;. Contiene la mayoría de las aplicaciones que instalamos sin la mediación de la distribución.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dentro de cada una de las jerarquías hay varios directorios en los  que se distribuyen los archivos de las aplicaciones dependiendo del tipo de archivo. Por ejemplo, los ejecutables se encuentran en los directorios &lt;em&gt;bin&lt;/em&gt; y las librerías en &lt;em&gt;lib&lt;/em&gt;. En mi ordenador el ejecutable &lt;em&gt;cp&lt;/em&gt;, que es esencial para el sistema se encuentra en &lt;em&gt;/bin/cp&lt;/em&gt;, el editor de textos &lt;em&gt;gedit&lt;/em&gt; que ha sido instalado por la distribución y no es esencial para el sistema se encuentra en &lt;em&gt;/usr/bin/gedit&lt;/em&gt; y el alineador de secuencias &lt;em&gt;bwa&lt;/em&gt; que yo he instalado manualmente sin utilizar el gestor de paquetes se encuentra en &lt;em&gt;/usr/local/bin/bwa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A diferencia de otros sistemas operativos en los sistemas Linux las  aplicaciones normalmente no están contenidas en un sólo directorio. Los ejecutables están en &lt;em&gt;bin&lt;/em&gt;, las librerías de los que dependen en &lt;em&gt;lib&lt;/em&gt;, etc. Cuando se instalan programas estáticos, que incluyen todas sus librerías, suelen instalarse en &lt;em&gt;/opt/&lt;/em&gt;. &lt;em&gt;opt/&lt;/em&gt; sigue un modelo similar al &lt;em&gt;Archivos de programa&lt;/em&gt; de &lt;em&gt;Windows&lt;/em&gt;. No es muy común que los programas se instalen de esta forma en &lt;em&gt;Linux&lt;/em&gt;, pero algunos programas como el &lt;em&gt;IDE java eclipse&lt;/em&gt; sí suelen instalarse en /opt&lt;/p&gt;

&lt;h2 id=&#34;instalando-programas&#34;&gt;Instalando programas&lt;/h2&gt;

&lt;h3 id=&#34;readme-e-install&#34;&gt;README e INSTALL&lt;/h3&gt;

&lt;p&gt;Cuando queramos instalar aplicaciones que no estén en repositorios o  que la aplicación que queremos está pero necesitamos una versión más  nueva, tendremos que ir programa por programa instalandolo. No existe una sola forma de instalarlos, pero si que todos los programas suelen tener algún tipo de documento en el que se explica como   instalar el programa. Normalmente este documento suele llamarse README o INSTALL, aunque no  hay ninguna regla que diga que esos sean los nombres, por lo que lo  primero que tenemos que hacer cuando nos descargemos la aplicación es  buscar el documento en el que se encuentre el modo de instalar la  aplicación.&lt;/p&gt;

&lt;h3 id=&#34;instalando-programas-compilados&#34;&gt;Instalando programas compilados&lt;/h3&gt;

&lt;p&gt;Una vez hemos visto dónde debemos instalar los programas que administremos sin la ayuda de la distribución (&lt;em&gt;/usr/local&lt;/em&gt;) vamos a ver como instalaríamos el mapeador de secuencias cortas &lt;a href=&#34;http://bowtie-bio.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;bowtie&lt;/a&gt;. En su página de  &lt;a href=&#34;https://sourceforge.net/projects/bowtie-bio/files/bowtie/1.1.2/&#34; target=&#34;_blank&#34;&gt;descargas&lt;/a&gt; encontramos los siguientes ficheros:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bowtie-1.1.2-src.zip&lt;/li&gt;
&lt;li&gt;bowtie-1.1.2-macos-x86_64.zip&lt;/li&gt;
&lt;li&gt;bowtie-1.1.2-linux-x86_64.zip&lt;/li&gt;
&lt;li&gt;bowtie-1.1.2-mingw-x86_64.zip&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los ficheros de interés en un sistema Linux son los marcados como linux-x86_64 y src. El primeros incluyen el programa compilado y el segundo el código fuente listo para compilar. Normalmente si se nos ofrece el programa precompilado para nuestra arquitectura podemos simplemente copiar el programa a &lt;em&gt;/usr/local&lt;/em&gt;. En este caso el programa lo han compilado para la arquitecturas x86_64. x86_64 se refiere a los microprocesadores &lt;em&gt;Intel&lt;/em&gt; y &lt;em&gt;AMD&lt;/em&gt; de 64 bits.&lt;/p&gt;

&lt;p&gt;Esta arquitectura no tiene que coincidir con nuestro procesador sino  con la versión de la distribución que tenemos instalada. Por ejemplo, Ubuntu y Debian tienen versiones para 32 y 64 bits, pero en un ordenador con un microprocesador de 64 bits podemos optar por  instalar la versión de la distribución de 32 bits. La arquitectura del programa compilado debe coincidir con la de la  distribución que tengamos instalada, no con la de nuestro  microprocesador. Para poder saber la arquitectura de nuestro sistema operativo, podemos  usar el comando &lt;code&gt;uname&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ uname -p
  x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supongamos que queremos instalar la versión de 64 bits del programa precompilado. Una vez que hemos descargado el fichero zip (que en muchas ocasiones será en realidad un tar.gz), lo descomprimimos. En el directorio descomprimido encontramos los ejecutables, en este caso el &lt;em&gt;bowtie&lt;/em&gt; y otros archivos adicionales, en este caso &lt;em&gt;scrips&lt;/em&gt; en el directorio &lt;em&gt;scripts&lt;/em&gt; y ficheros de ejemplos en los directorios &lt;em&gt;indexes&lt;/em&gt;, &lt;em&gt;genomes&lt;/em&gt; y &lt;em&gt;reads&lt;/em&gt;. Es posible que entre todos estos ficheros haya un &lt;em&gt;README&lt;/em&gt; o un &lt;em&gt;INSTALL&lt;/em&gt; si es así debemos leerlos antes de continuar.&lt;/p&gt;

&lt;p&gt;La forma más sencilla de instalar el programa es mover el directorio completo a &lt;em&gt;/usr/local/bowtie/&lt;/em&gt;. Una vez hecho deberemos añadir los directorios en los que hay ejecutables a nuestro $PATH. Sino lo hacemos no podremos ejecutar el programa a no ser que incluyamos la ruta completa al ejecutable &lt;em&gt;/usr/local/bowtie/bowtie&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para incluir el directorio con los ejecutables en la variable &lt;em&gt;PATH&lt;/em&gt; debemos modificar la variable con la siguiente orden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ export PATH=$PATH:/usr/local/bowtie/:/usr/local/bowtie/scripts/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez ejecutada esta orden ya podríamos ejecutar el bowtie en la  terminal. El problema de este método es que cada vez que nos salimos de la sesión  del terminal esta modificación del $PATH se pierde. Para que el $PATH sea el que deseamos siempre que entremos al sistema el comando anterior debe ser ejecutado, esto podemos conseguirlo  incluyéndolo en el fichero &lt;em&gt;.bashrc&lt;/em&gt; situado en nuestra $HOME. &lt;em&gt;.bashrc&lt;/em&gt; se ejecuta automáticamente cada vez que entramos en un &lt;em&gt;shell&lt;/em&gt; y se utiliza para adaptar las variables de entorno, como por ejemplo $PATH, a nuestras necesidades.&lt;/p&gt;

&lt;p&gt;Ejercicios:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Instala la ultima versión de ncbi-blast+&lt;/li&gt;
&lt;li&gt;Instala la ultima versión de &lt;a href=&#34;https://ccb.jhu.edu/software/tophat/index.shtml&#34; target=&#34;_blank&#34;&gt;tophat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala otra vez bowtie pero esta vez como usuario que no tiene  permisos de administrador. Cuando ejecutes bowtie se ha de utilizar la  instalación que acabas de hacer.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;instalando-un-programa-desde-el-código-fuente&#34;&gt;Instalando un programa desde el código fuente&lt;/h3&gt;

&lt;p&gt;Cuando no tenemos la posibilidad de instalarnos el programa ni desde  la distribuición ni usando binarios compilados, podemos optar por  instalar un programa partiendo desde el código fuente, para ello primero tenemos que compilarlo. Compilar significa traducir el código en texto escrito por humanos en un código que el ordenador entienda; codigo binario. Este suele ser un caso bastante habitual en las aplicaciones  bioinformáticas, para los casos en los que los desarrolladores no han  creado binarios compilados para nuestra arquitectura.&lt;/p&gt;

&lt;p&gt;Normalmente los ficheros con el código fuente son ficheros comprimidos &lt;em&gt;tar.gz&lt;/em&gt;, pero en el ejemplo que nos ocupa es un fichero comprimido &lt;em&gt;zip&lt;/em&gt;. Una vez descomprimido normalmente encontraremos un fichero &lt;em&gt;INSTALL&lt;/em&gt; o &lt;em&gt;README&lt;/em&gt; si es así debemos leerlos antes de continuar.&lt;/p&gt;

&lt;p&gt;El caso más habitual es que entre los archivos descomprimidos haya un &lt;em&gt;shell script&lt;/em&gt; ejecutable llamado &lt;em&gt;configure&lt;/em&gt;. Si es así el procedimiento a seguir suele ser ejecutar la secuencia de comandos &lt;em&gt;./configure&lt;/em&gt;, &lt;em&gt;make&lt;/em&gt;, &lt;em&gt;make install&lt;/em&gt;. &lt;em&gt;configure&lt;/em&gt; verificará que nuestro sistema dispone de todos las  librerías y utilidades necesarias para instalar el programa y creará una serie de ficheros &lt;em&gt;Makefile&lt;/em&gt;. Una vez terminado el &lt;em&gt;configure&lt;/em&gt; y creados los &lt;em&gt;Makefile&lt;/em&gt; satisfactoriamente podemos ejecutar el comando &lt;em&gt;make&lt;/em&gt; y el programa se compilará para nuestra arquitectura. El &lt;em&gt;configure&lt;/em&gt; también suele ser el encargado de determinar en qué jerarquía del sistema de archivos se instalará el programa. Lo habitual es que estos programas compilados manualmente se instalen en la tercera jerarquía, &lt;em&gt;/usr/local/&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para poder compilar los programas necesitamos tener instaladas una serie de aplicaciones. En Ubuntu por defecto estas aplicaciones no se instalan en el sistema. Para instalarlas debemos instalar el paquete build-essential:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ sudo apt-get install build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este comando instalará, entre otras cosas el compilador &lt;em&gt;gcc&lt;/em&gt; y los &lt;em&gt;headers&lt;/em&gt; de las librerías básicas del sistema. Los &lt;em&gt;headers&lt;/em&gt; se encuentran en los paquetes &lt;em&gt;dev&lt;/em&gt; (&lt;em&gt;devel&lt;/em&gt; en &lt;em&gt;RedHat&lt;/em&gt; y derivados) y son necesarios para poder compilar programas que  requieran las librerías. Para compilar un programa que utilice una librería no es suficiente con  tener instalada la librería, necesitamos instalar el paquete &lt;em&gt;dev&lt;/em&gt; con los &lt;em&gt;headers&lt;/em&gt;. Si el &lt;em&gt;configure&lt;/em&gt; se queja de que alguna librería no está instalada lo más habitual es que no tengamos el correspondiente paquete &lt;em&gt;dev&lt;/em&gt; instalado.&lt;/p&gt;

&lt;p&gt;Una vez tenemos todas las librerías requeridas instaladas el compilador podrá compilar el programa cuando ejecutemos el &lt;em&gt;make&lt;/em&gt;. Este proceso debe terminar sin errores, si algo falla debemos leer la salida del &lt;em&gt;make&lt;/em&gt; y buscar el fallo. Normalmente el fallo suele deberse a la falta de alguna librería. Si el fallo es más complicado lo más recomendable es buscar primero en &lt;em&gt;google&lt;/em&gt; y si no encontramos la solución preguntar a los desarrolladores del software por el problema.&lt;/p&gt;

&lt;p&gt;Una vez compilado soló queda ejecutar &lt;em&gt;make install&lt;/em&gt; para que el software se instale. Como lo habitual es que el programa esté destinado a ser instalado en &lt;em&gt;/usr/local/&lt;/em&gt; para pode ejecutar el &lt;em&gt;make install&lt;/em&gt; deberemos tener privilegios de administrador.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con esto el programa debe estar listo para ser ejecutado puesto que  el binario ejecutable debe haber sido copiado por el comando &lt;em&gt;make install&lt;/em&gt; a algún directorio del $PATH, normalmente a &lt;em&gt;/usr/local/bin&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ejercicios&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Instala &lt;a href=&#34;http://www.htslib.org/&#34; target=&#34;_blank&#34;&gt;samtools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;http://bio-bwa.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;bwa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;https://github.com/ekg/freebayes&#34; target=&#34;_blank&#34;&gt;freebayes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;https://github.com/stamatak/standard-RAxML&#34; target=&#34;_blank&#34;&gt;RAxML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala la última version de &lt;a href=&#34;https://www.pymol.org/&#34; target=&#34;_blank&#34;&gt;PyMOL&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;instalando-programas-java&#34;&gt;Instalando programas Java.&lt;/h3&gt;

&lt;p&gt;Java es un lenguaje de programación de proposito general. Es un  lenguaje muy usado en programas de bioinformatica porque es un lenguaje  multiplataforma. Escribes una vez el codigo y lo puedes usar en los  distintos sistemas operativos.&lt;/p&gt;

&lt;p&gt;Cual es el truco? Tienes que tener instalado en el sistema el  interprete de java. Este interprete será especial para cada sistema  operativo, pero podrá ejecutar cualquier codigo java. Existen diferentes interpretes de java, algunos son software libre, y suelen estar en la  distribución y luego tenemos el java de Oracle.&lt;/p&gt;

&lt;p&gt;Para poder ejecutar un programa de java, necesitaremos un &lt;em&gt;Java runtime enviroment(JRE)&lt;/em&gt;. Podemos instalar varios:&lt;/p&gt;

&lt;h4 id=&#34;java-libres&#34;&gt;Java libres&lt;/h4&gt;

&lt;p&gt;Una forma de tener java en nuestro sistema es mediante las versines  libres que nos ofrecen las distribuciones. Hay muchas variantes y  distintas versiones para cada variante, por lo que si no sabemos que  version instalar lo mejor es instalar la que la distribucion propone por defecto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ java
El programa «java» puede encontrarse en los siguientes paquetes:
* default-jre
* gcj-5-jre-headless
* openjdk-8-jre-headless
* gcj-4.8-jre-headless
* gcj-4.9-jre-headless
* openjdk-9-jre-headless
Intente: sudo apt install &amp;lt;paquete seleccionado&amp;gt;

~$ sudo apt install  default-jre
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;java-de-oracle&#34;&gt;Java de oracle&lt;/h4&gt;

&lt;p&gt;Oracle es la empresa dueña de java. Ellos son los que lo desarrollan y por lo tanto su interprete de java suele ser el de referencia. No es  software libre y por lo tanto las distrbuciones no lo pueden distribuir, pero existen formas sencilla de instalarlos. En ubuntu tenemos un &lt;a href=&#34;https://launchpad.net/~webupd8team/+archive/ubuntu/java&#34; target=&#34;_blank&#34;&gt;PPA&lt;/a&gt; en el que podemos instalar un instalador que nos instalará el java de oracle. Para instalarlo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ sudo add-apt-repository ppa:webupd8team/java
 ~$ sudo apt-get update
 ~$ sudo apt-get install oracle-java8-installer
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;ejecutar-programas-java&#34;&gt;Ejecutar programas java&lt;/h4&gt;

&lt;p&gt;Como siempre lo primero que tenemos que hacer es leernos la  documentación donde nos diga como ejecutarlo. Una forma habitual de  distribuir los programas en java es distribuyendo un fichero &lt;code&gt;.jar&lt;/code&gt;. P.ej trimmomatic. En estos casos para ejecutarlos lo tendremos que hacer de la siguiente manera:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ java -jar Trimmommatic.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otros programas en cambio se distribuyen con un ejecutable que se puede ejecutar directamente. P.ej: Fastqc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ fastqc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En algunos casos como el del &lt;a href=&#34;http://software.broadinstitute.org/software/igv/&#34; target=&#34;_blank&#34;&gt;IGV&lt;/a&gt;, no hace falta que nos instalemos el programa, podemos ejecutarlo direcmente desde la web. Para ello necesitaremos un &lt;em&gt;java web start&lt;/em&gt;. &lt;code&gt;javaws&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-cache search javaws
icedtea-netx-common - NetX - implementation of the Java Network Launching Protocol (JNLP)
icedtea-netx - NetX - implementation of the Java Network Launching Protocol (JNLP)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez que tengamos instalado el javaws, podemos seguir las  instrucciones de la pagina web para lanzar el programa. Normalmente un  click.&lt;/p&gt;

&lt;p&gt;Ejercicios:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Instala  y ejecuta &lt;a href=&#34;http://www.usadellab.org/cms/?page=trimmomatic&#34; target=&#34;_blank&#34;&gt;trimmomatic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala y ejecuta &lt;a href=&#34;http://varscan.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;VarScan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;http://www.bioinformatics.babraham.ac.uk/projects/fastqc/&#34; target=&#34;_blank&#34;&gt;FastQC&lt;/a&gt;¿ Como es el ejecutable para lanzar el fastq?¿Podrias modificarlo?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;p&gt;Python es otro lenguaje de programación de proposito general. Es un  lenguaje interpretado, por lo que no hay que traducir el código fuente  en código binario. De eso ya se encargara el interprete de python cada  vez que ejecutamos algo.&lt;/p&gt;

&lt;p&gt;Normalmente las distribuciones de linux suelen instalar python por  defecto. Ahora mismo hay dos versiones de python conviviendo juntas;  python2 y python3. Cuando veamos python a secas, hará referencia a  python2. Se pueden instalar las dos simultaneamente y tendremos que usar la versión que nuestro programs/libreria requiera. Cuando instalamos una aplicacion en python solo lo instalaremos para la  versión que estemos usando en ese momento. Las librerias son únicas para esa versión. Para saber cual de las 2 versiones estamos usando podemos  usar el comando &lt;code&gt;which&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Tenemos varios metodos para instalar aplicaciones de python.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instalarlos desde los repositorios.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python tiene un repositorio de software llamado&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;pypi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;donde muchos desarroladores “suben” sus programas. Para poder instalar estos programas necesitamos un programa que se llama 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;   pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;. Con pip podremos administrar los paquetes del repositorio pypi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ~$ sudo apt-get install python-pip
    ...
    ~$ pip install nombre_programa
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Utilizando el script de instalación que suelen tener los  programas. Una vez descomprimido, entramos en el directorio y ejecutamos la siguiente orden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ tar zxvf programa_python.tar.gz
 ...
 ~$ cd programa_python
 ~$ python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Si el programa es un solo ejecutable, lo podemos instalar como cualquier otro ejecutable.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;virtualenv&#34;&gt;Virtualenv&lt;/h4&gt;

&lt;p&gt;Python nos permite, en aquellos entornos en los que no tenemos  permisos para instalar fuera de nuestra HOME, crear un entorno virtual  en el directorio que le digamos. Así, podremos instalar las apliaciones  que necesitemos sin hacer cambios en el sistema. Con el comando &lt;code&gt;virtualenv&lt;/code&gt; crearemos un entorno virtual en python2. Y con el comando &lt;code&gt;pyvenv&lt;/code&gt; crearemos un entorno virtual en python3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@virtual:~$ virtualenv pyenv2
Running virtualenv with interpreter /usr/bin/python2
New python executable in /home/user/pyenv2/bin/python2
Also creating executable in /home/user/pyenv2/bin/python
Installing setuptools, pkg_resources, pip, wheel...done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez creados el  entorno virtual, vemos que tenemos 1 nuevos  directorio: pyenv2. Para user el entorno virtual tendremos que  activarlo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@virtual:~$ source pyenv2/bin/activate
user@virtual:~$ source pyenv2/bin/activate
(pyenv2) user@virtual:~$ which python
/home/user/pyenv2/bin/python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez activado, vemos que el el prompt tenemos el nombre de nuestro entorno virtual entre paréntesis. A partir de ahí todo comando o  libreria que instalemos en python se instalará en el entorno virtual.&lt;/p&gt;

&lt;p&gt;Ejercicios:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Instala &lt;a href=&#34;http://biopython.org/&#34; target=&#34;_blank&#34;&gt;Biopython&lt;/a&gt; en el sistema&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;http://pandas.pydata.org/&#34; target=&#34;_blank&#34;&gt;pandas&lt;/a&gt; en el sistema&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;https://github.com/JoseBlanca/ngs_crumbs&#34; target=&#34;_blank&#34;&gt;ngs_crumbs&lt;/a&gt; en el sistema.&lt;/li&gt;
&lt;li&gt;Crea un entorno virtual en python2 y repite los ejercicios 1 y 3 pero instalandolos en el entorno virtual&lt;/li&gt;
&lt;li&gt;Instala la &lt;a href=&#34;https://www.python.org/downloads/release/python-352/&#34; target=&#34;_blank&#34;&gt;última versión de python disponible&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;r&#34;&gt;R&lt;/h3&gt;

&lt;p&gt;R es un entorno y lenguaje de programación con un enfoque al análisis estadístico. Para poder ejecutar cualquier libreria o progrma en R lo primero que  tenemos que instalar es el interprete de R. La mejor forma es hacerlo  desde un paquete de la distribución:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ sudo apt-get install r-base
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;R utilizan un repositorio llamado cran para distribuir los paquetes. Estos paquetes se pueden instalar desde la propia &lt;em&gt;shell&lt;/em&gt; de R utilizando el commando install.packages(nombre_paquete):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ R

 &amp;gt;install.packages(&#39;ggplot2&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En R versiones concretas de librerias dependen de versiones concretas del interprete de R, por lo que si necesitamos una version concreta de  una libreria de R, tendremos que instalar la version de R de la que  dependa. En el caso que necesitemos dos versiones de R diferentes, lo  tendremos que instalar a mano, ya que las distribuciones no suelen  permitir la instalacion de diferentes versiones simultaneamente.&lt;/p&gt;

&lt;p&gt;Ejercicios:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Instalar la libreria XML de R. Usa el procedimiento interno de R.&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;https://www.bioconductor.org/&#34; target=&#34;_blank&#34;&gt;bioconductor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instalar &lt;a href=&#34;https://cran.rediris.es/&#34; target=&#34;_blank&#34;&gt;la última version de R&lt;/a&gt; manteniendo la que hemos instalado con la distribucion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;programas-que-se-pueden-instalar&#34;&gt;Programas que se pueden instalar&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;samtools&lt;/li&gt;
&lt;li&gt;bedtools&lt;/li&gt;
&lt;li&gt;velvet&lt;/li&gt;
&lt;li&gt;trinity&lt;/li&gt;
&lt;li&gt;phylip&lt;/li&gt;
&lt;li&gt;RAxML -&amp;gt; Compilarlo parece divertido . Hay que saber el prcesador que tienes.&lt;/li&gt;
&lt;li&gt;phyml&lt;/li&gt;
&lt;li&gt;emboss&lt;/li&gt;
&lt;li&gt;staden&lt;/li&gt;
&lt;li&gt;hmmer&lt;/li&gt;
&lt;li&gt;clustalw&lt;/li&gt;
&lt;li&gt;t-coffe&lt;/li&gt;
&lt;li&gt;repeatmasker -&amp;gt; Este es dificil.&lt;/li&gt;
&lt;li&gt;repeatexplorer -&amp;gt; Este es dificil.&lt;/li&gt;
&lt;li&gt;java:&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;picard-tools&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;python&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Biopython&lt;/li&gt;
&lt;li&gt;matplotlib&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Administrador</title>
      <link>https://www.marcusrb.com/unix/08-administrador/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/08-administrador/</guid>
      <description>

&lt;h1 id=&#34;administrador&#34;&gt;Administrador&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administrador.html#sudo&#34; target=&#34;_blank&#34;&gt;sudo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administrador.html#su&#34; target=&#34;_blank&#34;&gt;su&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los sistemas Unix entre los que se encuentra Linux, son sistemas  multiusuario, en los que muchos usuarios pueden usar el sistema  concurrentemente. No todos los usuarios tienen los mismos permisos en el sistema, existe un usuario especial llamado root que es el  administrador o superusuario.&lt;/p&gt;

&lt;p&gt;El usuario root a diferencia del resto de los usuarios, no tiene su carpeta personal en &lt;code&gt;/home&lt;/code&gt; sino que la tiene en una carpeta separada: &lt;code&gt;/root&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Por defecto un usuario no puede modificar nada excepto su carpeta  personal. Por ejemplo un usuario no puede instalar ninguna aplicacion  fuera de sus carpeta personal. Para poder hacerlo el usuario tiene dos  opciones:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Adquirir temporalmente privilegios de root&lt;/li&gt;
&lt;li&gt;Convertirse en root.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;sudo&#34;&gt;sudo&lt;/h3&gt;

&lt;p&gt;En ubuntu por defecto el usuario root está deshabilitado y la unica  forma de conseguir permisos de superusuario es mediente el comando &lt;code&gt;sudo&lt;/code&gt;. Escribiendo sudo en la consola delante de cualquier comando, estaremos ejecutando el comando con permisos de superusuario:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@virtual:~$ cat /etc/shadow
cat: /etc/shadow: Permiso denegado
user@virtual:~$ sudo cat /etc/shadow
root::17074:0:99999:7:::
daemon:*:17001:0:99999:7:::
bin:*:17001:0:99999:7:::
sys:*:17001:0:99999:7:::
sync:*:17001:0:99999:7:::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No todos los usuarios tienen permiso para usar sudo, solo aquellos  usuarios que son administradores. Para convertirse en administrador y  poder usar sudo, un usuario solo tiene que ser añadido al grupo sudo.&lt;/p&gt;

&lt;p&gt;Además con sudo se puede hacer login como root. Con la opcion &lt;code&gt;sudo -s&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@virtual:~$ sudo -s
[sudo] password for user:
root@virtual:~#
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;su&#34;&gt;su&lt;/h3&gt;

&lt;p&gt;Si no estamos en el grupo de &lt;code&gt;sudo&lt;/code&gt; o si &lt;code&gt;sudo&lt;/code&gt; no está disponible en el sistema, podemos usar el comando &lt;code&gt;su&lt;/code&gt; para poder cambiar de usuario en la misma sesión.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@virtual:~$ su
root@virtual:/home/user# id
uid=0(root) gid=0(root) grupos=0(root)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En ubuntu no podremos convertirnos en root ya que el usuario está  deshabilitado. Si queremos habilitarlo, lo unico que tenemos que hacer  es darle un password nuevo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ sudo passwd
[sudo] password for user:
Introduzca la nueva contraseña de UNIX:
Vuelva a escribir la nueva contraseña de UNIX:
passwd: contraseña actualizada correctamente
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;su&lt;/code&gt; ademas de cambiar al  usuario root, tambien permite cambiar a cualquier otro usuario, siempre  que sepamos el password. Un truco muy util para “convertirmos” en otro  usuario sin saber su password es combinar &lt;code&gt;sudo&lt;/code&gt; y &lt;code&gt;su&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user@virtual:~$ sudo su  user2
user2@virtual:/home/user$ id
uid=1001(user2) gid=1001(user2) grupos=1001(user2)
user2@virtual:/home/user$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Administrador de software</title>
      <link>https://www.marcusrb.com/unix/09-administrador-software/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/09-administrador-software/</guid>
      <description>

&lt;h1 id=&#34;administracion-de-software-1&#34;&gt;Administracion de software 1&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software1.html#repositorios&#34; target=&#34;_blank&#34;&gt;Repositorios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Herramientas de manejo de paquetes

&lt;ul&gt;
&lt;li&gt;APT&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software1.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;dpkg&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/administracion_software1.html#ejercicios-1&#34; target=&#34;_blank&#34;&gt;Ejercicios:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En los sistemas Linux las &lt;a href=&#34;http://es.wikipedia.org/wiki/Distribución_Linux&#34; target=&#34;_blank&#34;&gt;distribuciones&lt;/a&gt; se encargan de preparar una gran cantidad de software para ser instalado. Por ejemplo, cuando queremos instalar un programa de edición fotográfica como el &lt;em&gt;gimp&lt;/em&gt; no es necesario ni recomendable ir a la página web de los creadores del software para descargar el software. La distribución que estemos utilizando ya se ha encargado de buscar el  software y empaquetarlo para que el software pueda ser instalado de un  modo estandarizado. Por lo tanto si queremos instalar el &lt;em&gt;gimp&lt;/em&gt; o cualquier otro  programa lo que debemos hacer es utilizar las herramientas que la  distribución ha preparado para administrar el software que tenemos  instalado en nuestro ordenador. Por ejemplo, en Ubuntu, abriríamos la aplicación llamada &lt;em&gt;Software de Ubuntu&lt;/em&gt; y en ella buscaríamos el &lt;em&gt;gimp&lt;/em&gt;. Con un solo &lt;em&gt;click&lt;/em&gt; el programa quedaría instalado e integrado en nuestro sistema.&lt;/p&gt;

&lt;p&gt;Además todo el software instalado por este método se actualiza cuando los desarrolladores del software corrigen fallos o problemas de  seguridad sin que nosotros debamos preocuparnos por ello. La propia distribución se encarga de recopilar esas mejoras y de  aplicarlas a todo el software que tengamos instalado.&lt;/p&gt;

&lt;p&gt;El modo de operación es bastante distinto al usual en &lt;em&gt;Windows&lt;/em&gt;. En &lt;em&gt;Windows&lt;/em&gt; seríamos nosotros los que compraríamos el software y lo instalaríamos a partir de un CD o de un archivo descargado desde la  web. Esta es, dicho sea de paso, una de las fuentes de virus y troyanos  más habitual. Esto está cambiando y ya empezamos a tener un canal de  distribucion controlado por la propia microsoft.&lt;/p&gt;

&lt;p&gt;Mientras que las distribuciones Linux facilitan la instalación de un software certificado y libre de virus en &lt;em&gt;Windows&lt;/em&gt; debemos ser nosotros quienes nos encarguemos de verificar que el  software está libre de virus. Seríamos nosotros también los encargados de estar al tanto de instalar  las actualizaciones o los fallos de seguridad a no ser que cada software implemente esta funcionalidad.&lt;/p&gt;

&lt;p&gt;Las distribuciones distribuyen el software en forma de paquetes. Cada distribucion tiene su propio formato de paquetes. En debian y ubuntu se utiliza el formato .deb.  Las distribuciones organizan el software de  forma que se optimiza lo mejor que se pueda los recursos de un  ordenador. Por ejemplo si dos aplicaciones utilizan una libreria, en vez de poner la libreria por duplicado en cada una de las aplicaciones se  crea un nuevo paquete solo con la libreria y se crea una dependencia  desde las aplicaciones que la utilizan.  De las dependencias se encargan los sistemas de paquetes que veremos más adelante.&lt;/p&gt;

&lt;p&gt;Por desgracia, la cantidad de software incluido en las distribuciones no es infinito y, aunque el catálogo es amplio y más que suficiente  para la gran mayoría de las aplicaciones que un usuario doméstico o de  la administración pueda necesitar, hay programas, especialmente los  hechos para campos específicos que no están incluidos en las  distribuciones. Para biología Debian y Ubuntu incluyen programas como el EMBOSS, el  Blast o Biopython, pero hay otros muchos que no se incluyen y que  tendremos que gestionar nosotros mismos.&lt;/p&gt;

&lt;h2 id=&#34;repositorios&#34;&gt;Repositorios&lt;/h2&gt;

&lt;p&gt;Los repositorios son los bancos de datos que alojan los catalogos de  aplicaciones de las distribuciones. Todas las distribuciones tienen sus  propios repositorios, se encargan de mantenerlos actualizados, de hacer  tests de seguridad y de buscar errores en las aplcaciones.&lt;/p&gt;

&lt;p&gt;Ademas de los repositorios de de las distribuciones, tambien tenemos  repositorios de otras fuentes, los más conocidos son los PPA(Personal  Package Archives). Son repositorios que los usuarios ponen a disposicion de otros usuarios para que puedan instalarse aplicaciones que las  distribuciones no tienen, como por ejemplo el Java de oracle.&lt;/p&gt;

&lt;p&gt;En ubuntu y debian el fichero donde encontramos la configuracion de los repositorios es &lt;code&gt;/etc/apt/sources.list&lt;/code&gt;.  Cada una de las lineas del fichero nos da acceso a los paquetes de un  repositorio. En cada repositorio tenemos un listado con las aplicaciones que dispone, la version de cada paquete y una direcciones para poder  descargar e instalarla.&lt;/p&gt;

&lt;p&gt;En el directorio &lt;code&gt;/etc/apt/sources.list.d&lt;/code&gt; podemos tener tambien ficheros con más lineas de repositorios.&lt;/p&gt;

&lt;h2 id=&#34;herramientas-de-manejo-de-paquetes&#34;&gt;Herramientas de manejo de paquetes&lt;/h2&gt;

&lt;p&gt;Existen aplicaciones graficas para poder actualizar o instalar nuevos paquetes. En ubuntu tenemos el &lt;em&gt;Software de Ubuntu&lt;/em&gt; que nos permite instalar aplicaciones de una forma fácil y comoda.&lt;/p&gt;

&lt;p&gt;Tenemos que tener en cuenta que si usamos &lt;em&gt;Software de Ubuntu&lt;/em&gt; solo podremos acceder a unos cuantos paquetes disponibles en la distribucion. El porque es algo que podemos preguntar a Ubuntu.&lt;/p&gt;

&lt;p&gt;Por debajo esta aplicacion utiliza Apt(del inglés Advanced Package  Tool) que es un set de herramientas del nucleo de debian y que Ubuntu a  importado. APT es uno de los sistemas más avanzados en cuento a la  gestion de software.&lt;/p&gt;

&lt;h3 id=&#34;apt&#34;&gt;APT&lt;/h3&gt;

&lt;p&gt;Apt es un set de herramientas que nos ayudan a que la instalacion,  borrado o actualizacion de programas sea experiencia no traumatica. Apt  esta compuesto de muchos programas, en el curso nos vamos a centrar en  aquellos que consideramos más utiles: Para borrar, instalar, actualizar:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apt-get&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;upgrade&lt;/li&gt;
&lt;li&gt;dist-upgrade&lt;/li&gt;
&lt;li&gt;install&lt;/li&gt;
&lt;li&gt;remove&lt;/li&gt;
&lt;li&gt;clean&lt;/li&gt;
&lt;li&gt;autoremove&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para hacer busquedas de paquetes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apt-cache&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;search&lt;/li&gt;
&lt;li&gt;show&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para hacer busquedas en los ficheros de los paquetes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apt-file&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;search&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Añadir repositorios PPA&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;add-apt-repository&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ejercicios&#34;&gt;Ejercicios:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Instalar un editor de texto grafico.&lt;/li&gt;
&lt;li&gt;Borrarlo junto con su configuracion.&lt;/li&gt;
&lt;li&gt;Se han quedado paquetes que no se usan huerfanos? Si es así desinstalalos.&lt;/li&gt;
&lt;li&gt;Quiero alinear una secuencia contra un genoma usando el blast,  para ello tengo que crear una base de datos a partir del genoma que el  blast pueda usar. El comando para hacerlo se llama makeblastdb. Como lo  puedo instalar?&lt;/li&gt;
&lt;li&gt;Que versión del editor de texto has instalado?&lt;/li&gt;
&lt;li&gt;Que version de &lt;code&gt;inkscape&lt;/code&gt; tienes disponible  para instalar?&lt;/li&gt;
&lt;li&gt;Instala &lt;a href=&#34;https://atom.io/&#34; target=&#34;_blank&#34;&gt;atom&lt;/a&gt; desde un &lt;a href=&#34;https://launchpad.net/~webupd8team/+archive/ubuntu/atom&#34; target=&#34;_blank&#34;&gt;repositorio&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;dpkg&#34;&gt;dpkg&lt;/h3&gt;

&lt;p&gt;Es otra herramienta para interactuar con paquetes .deb. Con las  diferentes opciones de dpkg se pueden instalar y borrar programas pero  al no tener en cuenta las dependencias , lo hace más tedioso de usar. Aunqie tiene varias opciones que las hacen muy util:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dpkg -l&lt;/code&gt; : Lista todas las aplicaciones del sistema, las que se han instalado como las que se han borrado&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpkg -L&lt;/code&gt;  paquete : Lista la ruta de todos los ficheros que se han intalado al instalar el paquete.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ejercicios-1&#34;&gt;Ejercicios:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Cuantos paquetes tienes instalados en tu sistema?&lt;a href=&#34;https://linuxprograms.wordpress.com/2010/05/11/status-dpkg-list/&#34; target=&#34;_blank&#34;&gt;Pista&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cuantos ficheros se instalan cuando instalas el paquete que instala el makeblastdb. Cuantos de ellos son ejecutables?&lt;/li&gt;
&lt;li&gt;Utilizando apt-get descargate el paquete inkscape, pero no lo  instales. Despues intenta instalarlo con dpkg(mira en el manual cual es  la opcion para instalar paquetes). Que ocurre?&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Control de procesos</title>
      <link>https://www.marcusrb.com/unix/03-control-procesos/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/03-control-procesos/</guid>
      <description>

&lt;h1 id=&#34;procesos&#34;&gt;Procesos&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/control_procesos.html#ps&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;ps&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/control_procesos.html#kill&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;kill&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/control_procesos.html#free&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;free&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/control_procesos.html#top&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;top&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/control_procesos.html#screen-y-byobu&#34; target=&#34;_blank&#34;&gt;screen y byobu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/control_procesos.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un &lt;a href=&#34;https://en.wikipedia.org/wiki/Process_(computing)&#34; target=&#34;_blank&#34;&gt;proceso&lt;/a&gt; es una instancia de un programa en ejecución. Programas y procesos son entidades distintas. En un sistema operativo multitarea, múltiples instancias de un programa pueden ejecutarse simultáneamente. Cada instancia es un proceso separado.&lt;/p&gt;

&lt;p&gt;Prácticamente todo lo que se está ejecutando en el sistema en cualquier momento es un proceso, incluyendo la &lt;em&gt;shell&lt;/em&gt;, el ambiente gráfico, que puede tener múltiples procesos, etc.&lt;/p&gt;

&lt;p&gt;Linux, como ya hemos visto, es un sistema operativo multitarea y  multiusuario. Esto quiere decir que múltiples procesos pueden operar simultáneamente  sin interferir unos con otros. Por ejemplo, si cinco usuarios desde equipos diferentes, ejecutan el  mismo programa al mismo tiempo, habría cinco instancias del mismo  programa, es decir, cinco procesos distintos.&lt;/p&gt;

&lt;p&gt;Cada proceso que se inicia es identificado con un número de identificación único conocido como &lt;em&gt;Process ID&lt;/em&gt; (&lt;em&gt;PID&lt;/em&gt;), que es siempre un número natural.&lt;/p&gt;

&lt;p&gt;Haciendo análisis muchas veces ejecutaremos programas, crearemos procesos, que duren un tiempo considerable. Es interesante que durante el tiempo que dure el proceso podamos consultar su estado. Los entornos UNIX tienen una serie de herramientas para poder conocer el estado de los procesos y del sistema en general.&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;&lt;em&gt;ps&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;El comando &lt;em&gt;ps&lt;/em&gt; (&lt;em&gt;process status&lt;/em&gt;) nos informa sobre el estado de los procesos. Dependiendo de los parámetros que le demos nos mostrara un tipo de información u otra y unos procesos u otros.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si queremos obtener la lista completa de procesos podemos usar las opciones &lt;em&gt;-ef&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ps -ef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso la segunda columna nos indicará el &lt;em&gt;PID&lt;/em&gt; o identificador único del proceso.&lt;/p&gt;

&lt;h2 id=&#34;kill&#34;&gt;&lt;em&gt;kill&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;El comando &lt;em&gt;kill&lt;/em&gt;, a pesar de su nombre, no sólo sirve para  matar o terminar procesos sino también para enviar señales a los  procesos. La señal por defecto (cuando no se indica ninguna es terminar o matar el proceso), y la sintaxis es kill PID, siendo PID el número de ID del  proceso. Pero hay otras señales que podemos enviar. Así, por ejemplo, es posible enviar una señal de &lt;em&gt;STOP&lt;/em&gt; al proceso y se detendrá su ejecución, después cuando se quiera reanudar su ejecución podemos enviar la señal &lt;em&gt;CONTinuar&lt;/em&gt; y el proceso continuara desde donde se quedo detenido. Con kill -l podemos acceder a una lista de todas las señales que podemos mandar a un proceso:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kill -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El modo más convencional de matar un proceso es intentar primero que  muera ordenadamente con un -15 (Termination signal) y sino lo  conseguimos matarlo con un -9 (Kill signal):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kill -15 4719
$ kill -9 4719
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;free&#34;&gt;&lt;em&gt;free&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;free&lt;/em&gt; nos muestra información sobre el uso y disponibilidad de la memoria. Es aconsejable usar la opción &lt;em&gt;-h&lt;/em&gt; ya que así generará la información en una forma más fácil de leer para los seres *h*umanos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ free -h
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;top&#34;&gt;&lt;em&gt;top&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Una herramienta muy usada y muy útil para el monitoreo en tiempo real del estado de los procesos y de otras variantes del sistema es el  programa llamado top, se ejecuta desde la línea de comandos, es  interactivo y por defecto se actualiza cada 3 segundos.&lt;/p&gt;

&lt;p&gt;Estando dentro de la aplicación, presionando ‘h’ se accede a una  ayuda de los posibles comandos que permiten configurar top, por ejemplo, al presionar ‘s’ pregunta por el tiempo en segundos de actualización,  etc.&lt;/p&gt;

&lt;p&gt;Una alternativa más moderna al comando &lt;em&gt;top&lt;/em&gt;, que normalmente no es instalada por defecto, es &lt;em&gt;htop&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;screen-y-byobu&#34;&gt;screen y byobu&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;screen&lt;/em&gt; es permite tener varios shells a la vez en la misma terminal y permite cerrar la terminal sin que los shells sean destruidos. &lt;em&gt;screen&lt;/em&gt; tiene dos usos principales:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tener varios shells abiertos bajo una sola sesión SSH&lt;/li&gt;
&lt;li&gt;Lanzar procesos que queremos que se mantengan entre distintas sesiones.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;byobu&lt;/em&gt; es una modificación de &lt;em&gt;screen&lt;/em&gt; que lo hace más fácil de utilizar. La distribución Ubuntu mantiene un manual de ayuda para &lt;a href=&#34;https://help.ubuntu.com/community/Byobu&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;byobu&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Averigua todos los procesos que hay en ejecución.&lt;/li&gt;
&lt;li&gt;Cuantos procesos tiene tu usuario en ejecución?&lt;/li&gt;
&lt;li&gt;Ejecuta el comando “less” y averigua el &lt;em&gt;pid&lt;/em&gt; del proceso&lt;/li&gt;
&lt;li&gt;Termina (mata) el proceso “less”&lt;/li&gt;
&lt;li&gt;Abre proceso less dentro de byobu, sal de la terminal dejando el  proceso corriendo y vuelve a entrar en byobu. El proceso debería  continuar abierto&lt;/li&gt;
&lt;li&gt;Repite el ejercicio anterior en un ordenador remoto.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Expresiones regulares</title>
      <link>https://www.marcusrb.com/unix/06-expresiones-regulares/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/06-expresiones-regulares/</guid>
      <description>

&lt;h1 id=&#34;expresiones-regulares&#34;&gt;Expresiones regulares&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#expresiones-alternativas&#34; target=&#34;_blank&#34;&gt;Expresiones alternativas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#contenedores&#34; target=&#34;_blank&#34;&gt;Contenedores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#cuantificadores&#34; target=&#34;_blank&#34;&gt;Cuantificadores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#puntos-de-anclaje&#34; target=&#34;_blank&#34;&gt;Puntos de anclaje&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#sustituciones&#34; target=&#34;_blank&#34;&gt;Sustituciones&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#escapes&#34; target=&#34;_blank&#34;&gt;Escapes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#soluciones&#34; target=&#34;_blank&#34;&gt;Soluciones&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/expresiones_regulares.html#bibliografa&#34; target=&#34;_blank&#34;&gt;Bibliografía&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Las expresiones regulares son un medio para describir patrones de  texto. Imaginemos que no sólo queremos buscar en un texto todas las líneas que  contienen una palabra, como por ejemplo Barcelona, sino que sólo nos  interesan las líneas que &lt;em&gt;empiezan&lt;/em&gt; por la palabra Barcelona,  pero no las que contengan la palabra en cualquier otra posición. Describir el patrón “Barcelona” es trivial, tan sólo hay que escribir  “Barcelona”, pero ¿cómo podemos describir “La línea comienza por la  palabra Barcelona”. Las expresiones regulares permiten describir este tipo de patrones de  texto y muchos más por lo que nos serán de una gran utilidad. Además en Unix las expresiones regulares tienen un amplio soporte, tanto en las herramientas de procesamiento de ficheros de texto (&lt;em&gt;grep&lt;/em&gt;), o en los editores de texto (&lt;em&gt;vi&lt;/em&gt;, &lt;em&gt;emacs&lt;/em&gt;) como en los lenguajes de programación (&lt;em&gt;Perl&lt;/em&gt;, &lt;em&gt;Python&lt;/em&gt;). El único inconveniente de las expresiones regulares es que su sintaxis  no es trivial y que además varía ligeramente entre distintas  herramientas.&lt;/p&gt;

&lt;p&gt;En la web hay varios sitios en los que se pueden probar las expresiones regulares, como por ejemplo &lt;a href=&#34;https://regex101.com/&#34; target=&#34;_blank&#34;&gt;regex101&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Las expresiones regulares se evalúan carácter a carácter. Las más básicas son simplemente una lista de letras que forman una texto que debe coincidir exactamente con lo que buscamos. Por ejemplo con la expresión “Human” sólo coincidirá “Human”. Pero por fortuna las expresiones regulares nos permiten hacer búsquedas y substituciones mucho más complejas.&lt;/p&gt;

&lt;h2 id=&#34;expresiones-alternativas&#34;&gt;Expresiones alternativas&lt;/h2&gt;

&lt;p&gt;Una expresión u otra. Imaginemos que tenemos un fichero con los &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/origenes.txt&#34; target=&#34;_blank&#34;&gt;orígenes&lt;/a&gt; de los pacientes de un estudio sobre síndrome de Usher. Queremos seleccionar todos los pacientes que vienen de Valencia o Castellón. Podemos hacerlo utilizando la sintaxis para expresiones alternativas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -E &#39;Valencia|Castellón&#39; origenes.txt
  almeria Meliá Valencia sano
  Valencia	Paniagua	Castellón	usher1B
  Castellón	Sogorb	valencia	usher2B
  Granada Bastella Valencia sana
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La barra vertical (|) separa las expresiones alternativas. En este  caso significa que la palabra encontrada puede ser Valencia o Castellón.&lt;/p&gt;

&lt;h2 id=&#34;contenedores&#34;&gt;Contenedores&lt;/h2&gt;

&lt;p&gt;En muchas ocasiones nos interesa seleccionar patrones que pueden  tener en una posición varias letras distintas. Por ejemplo podríamos describir el patrón “comienza por Usher y después  tiene un número” o “comienza por usher y después tiene un par de  letras”. Busquemos todas las líneas que tienen la palabra Usher o usher:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -E --color &#39;[uU]sher&#39; origenes.txt
  Hospital	apellido_paciente	Biobanco	Tipo_Usher
  Barcelona	Castells	Barcelona	Usher2A
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Al poner las letras entre corchetes indicamos que el carácter que  aparezca en esa posición puede ser cualquiera de los caracteres  indicados. En este caso la expresión coincidente podría ser Usher u usher.&lt;/p&gt;

&lt;p&gt;Utilizando esta técnica podemos también indicar rangos de caracteres, como por ejemplo “aquellos con Usher tipo 0,1 ó 2”:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -E --color &#39;[uU]sher[0-2]&#39; origenes.txt
  Barcelona	Castells	Barcelona	Usher2A
  Mallorca	Pagan	Barcelona	usher1b
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existen rangos y tipos de caracteres predefinidos que podemos utilizar como:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;POSIX&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;ASCII&lt;/th&gt;
&lt;th&gt;Significado&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:alnum:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[A-Za-z0-9]&lt;/td&gt;
&lt;td&gt;Caracteres alfanuméricos (letras y números)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:word:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[A-Za-z0-9_]&lt;/td&gt;
&lt;td&gt;Caracteres alfanuméricos y “_”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:alpha:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[A-Za-z]&lt;/td&gt;
&lt;td&gt;Caracteres alfabéticos&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:blank:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[ \t]&lt;/td&gt;
&lt;td&gt;Espacio y tabulador&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:space:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[ \t\r\n\v\f]&lt;/td&gt;
&lt;td&gt;Espacios&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:digit:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[0-9]&lt;/td&gt;
&lt;td&gt;Dígitos&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:lower:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[a-z]&lt;/td&gt;
&lt;td&gt;Letras minúsculas&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:upper:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[A-Z]&lt;/td&gt;
&lt;td&gt;Letras mayúsculas&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[:punct:]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;[][!”#$%&amp;amp;’()*+,./:;&amp;lt;=&amp;gt;?@\^_`{|}~-]&lt;/td&gt;
&lt;td&gt;Caracteres de puntuación&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Por ejemplo, podríamos seleccionar cualquier dígito o letra:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ grep --color -E &#39;[uU]she[[:alpha:]]&#39; origenes.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si nos da igual que en una posición haya un carácter u otro podemos  utilizar un punto (.). Por ejemplo, seleccionar aquellos individuos con  subtipo A o B:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep --color -E &#39;[Uu]sher.[[:alpha:]]&#39; origenes.txt
  Barcelona	Castells	Barcelona	Usher2A
  Mallorca	Pagan	Barcelona	usher1b
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dentro de los contenedores resultan también bastante útiles las negaciones. Podemos, por ejemplo, seleccionar cualquier carácter que no sea un 2 o un 3 añadiendo “^” tras el primer corchete:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep --color -E &#39;sher[^23]&#39; origenes.txt
  Mallorca	Pagan	Barcelona	usher1b
  madrid	Cardosa	madrid	usher1a
  Valencia	Paniagua	Castellón	usher1B  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cuantificadores&#34;&gt;Cuantificadores&lt;/h2&gt;

&lt;p&gt;Además de indicar qué caracteres queremos permitir podemos  seleccionar cuantas veces deben aparecer. Si no añadimos nada que indique lo contrario se asume que el carácter  debe aparecer una vez, pero podríamos pedir que el carácter aparezca un  número distinto de veces:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;”?”, el carácter aparece ninguna o una vez. “usher1?” coincidiría con “usher” o “usher1”.&lt;/li&gt;
&lt;li&gt;”*”, cero,  una o varias veces.&lt;/li&gt;
&lt;li&gt;”+”, al menos una vez.&lt;/li&gt;
&lt;li&gt;“{4}”, cuatro veces.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;“{4,10}”, entre 4 y 10 veces&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ grep --color -E &#39;sher2.?&#39; origenes.txt
Barcelona	Castells	Barcelona	Usher2A
Albacete	Blanca	Madrid	usher2
Castellón	Sogorb	valencia	usher2B
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;puntos-de-anclaje&#34;&gt;Puntos de anclaje&lt;/h2&gt;

&lt;p&gt;Además de poder indicar qué y cuántas veces queremos que algo aparezca podemos indicar dónde deseamos que lo haga. Los puntos de anclaje más utilizados son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;”^”, inicio de línea&lt;/li&gt;
&lt;li&gt;”$”, fin de línea&lt;/li&gt;
&lt;li&gt;”&amp;lt;”, principio de palabra&lt;/li&gt;
&lt;li&gt;”&amp;gt;”, fin de palabra&lt;/li&gt;
&lt;li&gt;“\b”, límite de palabra&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Líneas que comienzan por B:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep --color -E &#39;^B&#39; origenes.txt
  Barcelona	Castells	Barcelona	Usher2A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Líneas que terminan por B:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep --color -E &#39;B$&#39; origenes.txt
  Valencia	Paniagua	Castellón	usher1B
  Castellón	Sogorb	valencia	usher2B  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sustituciones&#34;&gt;Sustituciones&lt;/h2&gt;

&lt;p&gt;Las expresiones regulares además de ser útiles para buscar patrones sirven para sustituirlos. Por ejemplo podemos sustituir madrid por Madrid con el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ sed -r &#39;s/madrid/Madrid/&#39; origenes.txt
 ...
 Albacete	Blanca	Madrid	usher2
 Madrid	Cardosa	madrid	usher1a
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ya vimos que si queríamos que la expresión se utilizase más de una vez en cada línea debíamos utilizar el modificador “g”:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sed -r &#39;s/madrid/Madrid/g&#39; origenes.txt
  ...
  Albacete	Blanca	Madrid	usher2
  Madrid	Cardosa	Madrid	usher1a
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Estas sustituciones además de soportar los patrones sencillos soportan todo lo que hemos visto anteriormente. Por ejemplo, podemos eliminar la primera columna del fichero con el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sed -r &#39;s/^[[:alnum:]]*\t//&#39; origenes.txt
  apellido_paciente	Biobanco	Tipo_Usher
  Castells	Barcelona	Usher2A
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si lo que queremos es guardar el patrón encontrado para utilizarlo en la sustitución debemos utilizar paréntesis. Los paréntesis indican que lo que hay dentro de ellos debe ser recordado para poder utilizado en la substitución. Por ejemplo, podríamos permutar las columnas 1 y 2 del fichero con el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sed -r &#39;s/^([[:alnum:]]*)\t([[:alnum:]_]*)/\2\t\1/&#39; origenes.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;escapes&#34;&gt;Escapes&lt;/h2&gt;

&lt;p&gt;Algunos caracteres tienen significados especiales, como ., $, (, ),  [, ], \ o ^ y si se quieren utilizar hay que escaparlos precediéndolos  con .&lt;/p&gt;

&lt;p&gt;El campo de las expresiones regulares es muy amplio y esta pequeña  introducción sólo ha pretendido mostrar algunas de las posibilidades de  esta gran herramienta. El mejor modo de aprender a utilizarlas es intentar hacer uso de ellas  en problemas concretos y echar una ojeada a algunos de los libros y  tutoriales que se han escrito sobre ellas.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Buscar las líneas en las que aparece la palabra bash en el archivo /etc/passwd.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Buscar en el archivo /etc/group todas las líneas que empiezan por &lt;em&gt;m&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;En el fichero anterior imprimir todas las líneas que no empiezan por &lt;em&gt;m&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;¿Cuántos ficheros README hay en los subdirectorios de /usr/share/doc?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;¿Qué ficheros o directorios en /etc continen un número en el nombre?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Trabajando con el fichero de los &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/origenes.txt&#34; target=&#34;_blank&#34;&gt;orígenes&lt;/a&gt; de los pacientes de Usher resolver las siguientes cuestiones.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Seleccionar los pacientes enviados por el hospital de Castellón.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Seleccionar los que vienen del Biobanco de Barcelona.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Buscar los pacientes que no tienen Usher3.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;En el fichero de pacientes de Usher hay algunas líneas separadas  por espacios y otras por tabuladores, cambiar todos los separadores a  comas.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Disponemos de un fichero con una &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/caracterizacion_plantas.txt&#34; target=&#34;_blank&#34;&gt;caracterización morfológica&lt;/a&gt; de unas plantas.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Recuperar aquellas plantas numeradas con 1 o con 3 dígitos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Añadir ceros al identificador de las plantas para que tengan todos 3 dígitos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Construir un nuevo fichero que incluya solo las filas sin datos faltantes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soluciones&#34;&gt;Soluciones&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Buscar las líneas en las que aparece la palabra bash en el archivo /etc/passwd.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ grep &#39;bash&#39; /etc/passwd&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Buscar en el archivo /etc/group todas las líneas que empiezan por &lt;em&gt;m&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ grep &#39;^m&#39; /etc/group&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;En el fichero anterior imprimir todas las líneas que no empiezan por &lt;em&gt;m&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ grep -v &#39;^m&#39; /etc/group&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;¿Cuántos ficheros README hay en los subdirectorios de /usr/share/doc?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ ls -R /usr/share/doc | grep &#39;^README$&#39; | wc -l&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;¿Qué ficheros o directorios en /etc continen un número en el nombre?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ ls /etc/ | grep &#39;[0-9]&#39;&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Seleccionar los pacientes enviados por el hospital de Castellón.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ grep --color -E &#39;^[cC]astell[oó]n&#39; origenes.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~$ grep --color -iE &#39;^castell[oó]n&#39; origenes.txt&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Seleccionar los que vienen del Biobanco de Barcelona.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ grep --color -iE &#39;.Barcelona&#39; origenes.txt&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Buscar los pacientes que no tienen Usher3.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ grep --color -iE &#39;usher[^3]&#39; origenes.txt&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;En el fichero de pacientes de Usher hay algunas líneas separadas  por espacios y otras por tabuladores, cambiar todos los separadores a  comas.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;~$ sed -r &#39;s/[[:blank:]]+/,/g&#39; origenes.txt&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Recuperar aquellas plantas numeradas con 1 o con 3 dígitos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep --color -E &#39;t[0-9]{1} |t[0-9]{3} &#39; caracterizacion_plantas.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Añadir ceros al identificador de las plantas para que tengan todos 3 dígitos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sed -r &#39;s/t([0-9]{1}) /t00\1 /g&#39; caracterizacion_plantas.txt | sed -r &#39;s/t([0-9]{2}) /t0\1 /g&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Construir un nuevo fichero que incluya solo las filas sin datos faltantes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -iE &#39;plant[0-9]* [0-9]+\.?[0-9]* [0-9]+\.?[0-9]* [0-9]+\.?[0-9]*&#39; numbers.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O con una versión más sencilla:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep --color -iE &#39;^plant[0-9]*( [0-9]\.[0-9]){3}&#39; numbers.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bibliografía&#34;&gt;Bibliografía&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://oreilly.com/catalog/9780596528126&#34; target=&#34;_blank&#34;&gt;Mastering regular expressions&lt;/a&gt; por Jeffrey E.F. Friedl.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oreilly.com/catalog/9780596520694&#34; target=&#34;_blank&#34;&gt;Regular Expressions Cookbook&lt;/a&gt; por Jan Goyvaerts y Steven Levithan.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.zytrax.com/tech/web/regex.htm&#34; target=&#34;_blank&#34;&gt;Regular Expressions User Guide&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.regular-expressions.info/tutorial.html&#34; target=&#34;_blank&#34;&gt;Regular Expression Tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Flujo de información</title>
      <link>https://www.marcusrb.com/unix/04-flujo-informacion/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/04-flujo-informacion/</guid>
      <description>

&lt;h1 id=&#34;flujos-de-información&#34;&gt;Flujos de información&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/pipes.html#flujos-de-informacin-estndar&#34; target=&#34;_blank&#34;&gt;Flujos de información estándar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/pipes.html#redireccin-del-flujo-estndar&#34; target=&#34;_blank&#34;&gt;Redirección del flujo estándar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/pipes.html#pipes&#34; target=&#34;_blank&#34;&gt;Pipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/pipes.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/pipes.html#soluciones&#34; target=&#34;_blank&#34;&gt;Soluciones&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los programas en línea de comandos, además de poder leer y escribir  en ficheros, pueden tomar argumentos como entrada, realizar una tarea e  imprimir una salida en la pantalla.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/cli_program.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Por ejemplo, al ejecutar el comando &lt;em&gt;ls&lt;/em&gt; se imprime un listado en la pantalla. Esto que acaba siendo impreso en la pantalla constituye lo que se denomina un flujo de información.&lt;/p&gt;

&lt;h2 id=&#34;flujos-de-información-estándar&#34;&gt;Flujos de información estándar&lt;/h2&gt;

&lt;p&gt;En todos los sistemas Unix existen tres flujos de información:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;standard input (stdin): datos que se envian al programa&lt;/li&gt;
&lt;li&gt;standard output (stdout): datos que devuelve el programa&lt;/li&gt;
&lt;li&gt;standard error (stderr): flujo usado por los programas para enviar un informe de errores&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/streams.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Los flujos permiten, por ejemplo, conectar unos programas con otros de manera que el &lt;em&gt;stdout&lt;/em&gt; de un programa se le pase a otro por &lt;em&gt;stdin&lt;/em&gt;, o guardar el stdout y el stderr en ficheros diferentes.&lt;/p&gt;

&lt;p&gt;Los flujos estándar se representan por un número:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stdin: 0&lt;/li&gt;
&lt;li&gt;stdout: 1&lt;/li&gt;
&lt;li&gt;stderr: 2&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;redirección-del-flujo-estándar&#34;&gt;Redirección del flujo estándar&lt;/h2&gt;

&lt;p&gt;El flujo estándar puede ser redirigido para que no se imprima en  pantalla, sino que quede almacenado en un fichero. Para redirigir el  flujo de información desde la pantalla a un fichero no necesitamos más  que utilizar el símbolo &lt;em&gt;&amp;gt;&lt;/em&gt; seguido del nombre de un fichero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls &amp;gt; listado.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si lo hacemos se creará un nuevo fichero y en él se escribirá lo que estaba destinado a la pantalla.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls
  listado.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En el caso de que el fichero de salida exista previamente será eliminado y vuelto a crear.&lt;/p&gt;

&lt;p&gt;Podríamos añadir contenidos al fichero antiguo sin borrarlo utilizando dos veces el símbolo mayor que &lt;em&gt;»&lt;/em&gt;. Por ejemplo, añadir el listado de archivos y directorios del directorio anterior en el árbol de directorios.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls .. &amp;gt;&amp;gt; listado.txt    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En los ejemplos anteriores, técnicamente lo que estamos haciendo redirigir el &lt;em&gt;standard output&lt;/em&gt;. Sin emabargo, si ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls -7 &amp;gt; listado.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observaremos que el archivo &lt;em&gt;listado.txt&lt;/em&gt; esta vacio y el programa habrá mostrado en pantalla un mensaje de error ya que la opción &lt;em&gt;-7&lt;/em&gt; no existe en &lt;em&gt;ls&lt;/em&gt;. En este caso el programa envía el mensaje de error al flujo &lt;em&gt;stderr&lt;/em&gt;, que no está siendo redirigido. Si quisiéramos redirigir también el &lt;em&gt;stderr&lt;/em&gt; deberíamos indicarlo así:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls -7 2&amp;gt; error.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este división de los flujos estándard nos permite guardanos por  separado el resultado normal de un programa y los avisos de error&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls &amp;gt; listado.txt 2&amp;gt; error.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existe tambien la posibilidad de redirigir el &lt;em&gt;stderr&lt;/em&gt; al &lt;em&gt;stdout&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls &amp;gt; listado.txt 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pipes&#34;&gt;Pipes&lt;/h2&gt;

&lt;p&gt;En Unix además de redirigir los flujos de información hacia un  fichero podemos unir el flujo de salida de un programa con el de entrada de otro utilizando un &lt;em&gt;pipe&lt;/em&gt; (tubería). El símbolo para el pipe es |.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/pipe.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hagamos un ejemplo con los comandos &lt;em&gt;wc&lt;/em&gt; (Word Count) y &lt;em&gt;cat&lt;/em&gt;. &lt;em&gt;wc&lt;/em&gt; sirve para contar líneas, palabras y caracteres. Veamos cuántos archivos y directorios hay en el directorio actual:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls &amp;gt; listado.txt
  ~$ wc listado.txt
   7  7 80 listado.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podríamos hacer lo mismo en un solo paso utilizando un pipe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls | wc
      7       7      80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso la salida del comando &lt;em&gt;ls&lt;/em&gt; (i.e., el &lt;em&gt;standard output&lt;/em&gt;) ha sido redirigida a la entrada del comando &lt;em&gt;wc&lt;/em&gt; (i.e., el &lt;em&gt;standard input&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Esta técnica es una de las grandes fortalezas de los sistemas Unix ya que permite enlazar comandos sencillos para realizar tareas complejas y vamos a utilizarla ampliamente durante el curso.&lt;/p&gt;

&lt;p&gt;Esta técnica posibilita, entre otras cosas, el procesamiento de los ficheros de texto de una forma potente y sencilla.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Salva la ruta del directorio actual (&lt;em&gt;pwd&lt;/em&gt;) en un archivo, muévete a otro directorio y añade la dirección actual al archivo creado&lt;/li&gt;
&lt;li&gt;Haz fallar el comando &lt;em&gt;mkdir&lt;/em&gt; y salva el mensaje de error en un fichero&lt;/li&gt;
&lt;li&gt;¿Cuántas líneas tiene el manual de &lt;em&gt;ps&lt;/em&gt;?&lt;/li&gt;
&lt;li&gt;Para el comando &lt;em&gt;pwd&lt;/em&gt; salva el &lt;em&gt;standard error&lt;/em&gt; en un archivo y redirige el &lt;em&gt;standard output&lt;/em&gt; también a ese archivo&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soluciones&#34;&gt;Soluciones&lt;/h2&gt;

&lt;p&gt;1.- Salva la ruta del directorio actual (&lt;em&gt;pwd&lt;/em&gt;) en un archivo, muévete a otro directorio y añade la dirección actual al archivo creado.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ pwd &amp;gt; directions.txt
  ~$ cd /bin/
  /bin$ pwd &amp;gt;&amp;gt; ~/directions.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.- Haz fallar el comando &lt;em&gt;mkdir&lt;/em&gt; y salva el mensaje de error en un fichero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ mkdir 2&amp;gt; error.log  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.- ¿Cuántas líneas tiene el manual de &lt;em&gt;ps&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Si lo hiciéramos sin &lt;em&gt;pipes&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ man ps &amp;gt; ps_manual.txt
  ~$ wc ps_manual.txt
      1188  6276 53338 ps_manual.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redirigiendo los flujos estandar con &lt;em&gt;pipes&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ man ps |wc
      1188    6276   53338
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.- Para el comando &lt;em&gt;pwd&lt;/em&gt; salva el &lt;em&gt;standard error&lt;/em&gt; en un archivo y redirige el &lt;em&gt;standard output&lt;/em&gt; también a ese archivo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ pwd 2&amp;gt; error.log 1&amp;gt;&amp;amp;2      
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redigir el &lt;em&gt;stdout&lt;/em&gt; al &lt;em&gt;stderr&lt;/em&gt; en un principio no es  algo común, suele hacerse al revés. Pero el ejercicio pretende demostrar que la redirección de flujos es posible en cualquier dirección&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>UNIX from Scratch</title>
      <link>https://www.marcusrb.com/unix/01-unix-intro/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/01-unix-intro/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Unix&#34; target=&#34;_blank&#34;&gt;Unix&lt;/a&gt; es una familia de sistemas operativos. La primera versión de Linux fue desarrollada a partir de 1969. Unix se caracteriza por ser portable y multitarea.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Unix#/media/File:Unix_history-simple.svg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/unix_history.png&#34; alt=&#34;Unix history&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hoy en día los sistemas operativos Unix son ampliamente utilizados en multitud de dispositivos que abarcan desde los supercomputadores más capaces hasta los teléfonos móviles más populares, pasando por los ordenadores que utilizamos diariamente en nuestros escritorios. La filosofía de los sistemas Unix se caracteriza por:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un sistema de ficheros jerárquico,&lt;/li&gt;
&lt;li&gt;una gran colección de pequeños programas que pueden trabajar en serie,&lt;/li&gt;
&lt;li&gt;el uso de ficheros de texto para almacenar los datos,&lt;/li&gt;
&lt;li&gt;tratar los dispositivos como ficheros.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt; y MacOS X son ejemplos de sistemas Unix.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/Unix&#34; target=&#34;_blank&#34;&gt;Unix&lt;/a&gt; es un sistema operativo portable, multitarea y multiusuario desarrollado a partir de 1969.&lt;/p&gt;

&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/Linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt; es una familia de sistemas operativos de tipo Unix que utilizan el kernel Linux. Linux puede instalarse en prácticamente cualquier ordenador personal además en en teléfonos móviles y supercomputadores.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/tux.png&#34; alt=&#34;Tux&#34; /&gt;&lt;/p&gt;

&lt;p&gt;El nombre proviene del programador original, un estudiante llamado Linus Torvals, que en 1991 completando las herramientas GNU desarrolladas por el proyecto GNU de la &lt;a href=&#34;http://www.fsf.org/&#34; target=&#34;_blank&#34;&gt;Fundación del Software Libre&lt;/a&gt;, creó la primera versión de este sistema operativo. El papel fundamental jugado por estas herramientas libres del proyecto GNU hace que este sistema operativo sea denominado también como GNU/Linux, pero en este texto utilizaremos la denominación más sencilla y corta.&lt;/p&gt;

&lt;p&gt;El desarrollo de Linux es uno de los ejemplos más claros de desarrollo de software libre por una comunidad dispersa de programadores. Cualquiera puede usar el sistema operativo, estudiarlo y modificarlo. Estos derechos están protegidos por la licencia &lt;a href=&#34;http://es.wikipedia.org/wiki/GPL&#34; target=&#34;_blank&#34;&gt;GPL&lt;/a&gt; (GNU General Public License).&lt;/p&gt;

&lt;h2 id=&#34;distribuciones&#34;&gt;Distribuciones&lt;/h2&gt;

&lt;p&gt;Linux, como cualquier otro sistema operativo, se compone de un gran número de piezas, que, en este caso, son desarrolladas de forma independiente por miles de programadores y proyectos. Normalmente estas piezas son integradas por un distribuidor y Linux es suministrado como una &lt;a href=&#34;http://es.wikipedia.org/wiki/Distribución_linux&#34; target=&#34;_blank&#34;&gt;distribución Linux&lt;/a&gt;. Las distribuciones Linux incluyen todo el software necesario para instalar un servidor o un escritorio. Algunas de las aplicaciones comúnmente incluidas incluyen: el navegador web Firefox y las aplicaciones de oficina LibreOffice.&lt;/p&gt;

&lt;p&gt;Existen cientos de distribuciones Linux. Estas distribuciones están adaptadas para usuarios o tareas específicas. Algunas de estas distribuciones están desarrolladas o apoyadas por empresas como Fedora (Red Hat) y &lt;a href=&#34;http://www.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt; (Canonical) mientras que otras son mantenidas por la propia comunidad de usuarios como &lt;a href=&#34;http://www.debian.org/&#34; target=&#34;_blank&#34;&gt;Debian&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;software-libre&#34;&gt;Software libre&lt;/h2&gt;

&lt;p&gt;El &lt;a href=&#34;http://es.wikipedia.org/wiki/Software_libre&#34; target=&#34;_blank&#34;&gt;software libre&lt;/a&gt; es software que puede ser utilizado, estudiado, modificado, copiado y redistribuido sin restricciones. Habitualmente el software libre suele ser además gratuito, pero ese no tiene por que ser necesariamente el caso.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/gpl_logo.png&#34; alt=&#34;GPL Logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En la práctica el software libre se distribuye junto al código fuente que lo hace posible y junto a una nota en la que se explican cuales son los derechos y las obligaciones del usuario final. Esta nota se denomina licencia. El movimiento del software libre fue iniciado por Richard Stallman en 1983. Stallman decidió crear un sistema compatible con Unix completamente libre al que llamó GNU (GNU is Not Unix). Con el tiempo este sistema acabaría uniéndose al kernel de Linus para formar un sistema operativo completo.&lt;/p&gt;

&lt;p&gt;Dado que las aplicaciones del software libre suelen ser gratuitas, su modelo de negocio suele basarse en el cobro de los servicios de soporte al usuario y de adaptación del software.&lt;/p&gt;

&lt;h1 id=&#34;introducción-a-ubuntu&#34;&gt;Introducción a Ubuntu&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/Ubuntu&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt; es una distribución Linux mantenida por la empresa Canonical. Está orientada a usuarios de escritorio y sus puntos fuertes son su facilidad de uso y de instalación. Aunque el escritorio es algo distinto al de Windows o Mac OS X familiarizarse con él para un usuario acostumbrado a cualquiera de los otros sistemas operativos no debería presentar muchos problemas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/ubuntu_logo.png&#34; alt=&#34;Ubuntu logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Su instalación resulta muy sencilla. Al instalarla, una gran cantidad de software se instala de forma automática para facilitar su uso como escritorio. Ejemplos de estos programas son LibreOffice o Firefox. Además de estos programas instalados por defecto una enorme cantidad de programas se encuentra disponible para ser instalados con unos pocos clicks de ratón.&lt;/p&gt;

&lt;p&gt;Ubuntu está basada en una distribución mantenida por la comunidad de usuarios llamada &lt;a href=&#34;http://www.debian.org/&#34; target=&#34;_blank&#34;&gt;Debian&lt;/a&gt;. El principal objetivo de Debian es crear un sistema operativo robusto que incluya la mayor proporción posible de programas libres.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/debian_logo.png&#34; alt=&#34;Debian&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Existen numerosos manuales de utilización de Ubuntu, pero algunas de las guías más completas son la &lt;a href=&#34;https://help.ubuntu.com/lts/ubuntu-help/index.html&#34; target=&#34;_blank&#34;&gt;Ubuntu Desktop Guide&lt;/a&gt; y el manual &lt;a href=&#34;http://ubuntu-manual.org/&#34; target=&#34;_blank&#34;&gt;Getting Started with Ubuntu&lt;/a&gt;. Vamos a recorrer lo principales conceptos de este sistema operativo basandonos en este &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/documentacion/Getting Started with Ubuntu 16.04.pdf&#34; target=&#34;_blank&#34;&gt;manual&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;los-usuarios&#34;&gt;Los usuarios&lt;/h2&gt;

&lt;p&gt;Los sistemas Unix son multiusuario, es decir soportan que varios usuarios los utilicen simultáneamente. Todos los usuarios, excepto uno, tienen unos privilegios bastante restringidos y no pueden modificar el sistema. De este modo unos usuarios se ven protegidos de las acciones de los otros.&lt;/p&gt;

&lt;p&gt;Existe un usuario especial llamado &lt;em&gt;root&lt;/em&gt; con privilegios de administración absolutos sobre el sistema. Para realizar las tareas cotidianas nunca hay que acceder al sistema como &lt;em&gt;root&lt;/em&gt;. En Ubuntu este usuario está deshabilitado por defecto y sólo se pueden adquirir los privilegios de administrador temporalmente.&lt;/p&gt;

&lt;h2 id=&#34;el-escritorio&#34;&gt;El escritorio&lt;/h2&gt;

&lt;p&gt;Todos las distribciones basadas en entronos graficos (GUI) suelen tener varios entornos de escritorio para eleguir. Los entornos de escritorio suelen diferir por:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;El estilo y apariencia del entorno&lt;/li&gt;
&lt;li&gt;La forma en la que los diferentes elementos se disponen en la pantalla&lt;/li&gt;
&lt;li&gt;La forma en la que el ususario navega por el escritorio&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En el caso de Ubuntu el entorno de escritorio por defecto se denomina Unity. Se caracteriza por tener dos barras, la denominada Menu Bar y el Launcher. El Menu Bar incorpora por una lado los menus de las aplicaciones que estań activas y, por otro, un area de indicadores que nos ofrecen informacion actualizada del sistema en todo momento. El Launcher es la barra vertical que facilita el acceso a las aplicaciones mas usadas y a su estado, además de a los discos montados y a la papelera. Además tenemos el selector de escritorios virtuales. En el launcher encontramos varias aplicaciones especiales:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;El menu&lt;/li&gt;
&lt;li&gt;El selector de escritorios virtuales&lt;/li&gt;
&lt;li&gt;La papelera&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los escritorios virtuales sirven para ampliar la zona de trabajo. Por defecto hay 4 escritorios virtuales que amplían nuestro monitor por cuatro.&lt;/p&gt;

&lt;h2 id=&#34;navegando-por-el-sistema-de-ficheros&#34;&gt;Navegando por el sistema de ficheros&lt;/h2&gt;

&lt;p&gt;Al sistema de ficheros se accede a traves del menu. Tenemos la posibilidad de buscar en la barra de busqueda o navegar directamente por el menu. Una vez que seleccionemos la carpeta se abrirá una ventana del navegador de ficheros con la carpeta seleccionada. Por cierto, los términos carpeta y directorio son sinónimos, al igual que fichero y archivo.&lt;/p&gt;

&lt;p&gt;Desde el launcher también podemos acceder a nuestra carpeta personal. Este directorio personal y sus subdirectorios son los únicos lugares en los que podremos almacenar nuestros archivos personales. El resto del sistema de archivos estará restringido para funciones de administración del sistema.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;p&gt;Para comprobar que no tenemos problemas de manejo del sistema vamos a realizar una serie de tareas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Explorar el escritorio abriendo programas, moviéndote entre escritorios virtuales, minimizando y maximizando las aplicaciones, etc.&lt;/li&gt;
&lt;li&gt;Navegar al directorio “Documentos” y comprobar si tenemos algún archivo guardado.&lt;/li&gt;
&lt;li&gt;Crear un subdirectorio llamado “curso” dentro del directorio “Documentos”.&lt;/li&gt;
&lt;li&gt;Crear un fichero de texto mediante el editor de textos gedit y guardarlo en el directorio que acabamos de crear.&lt;/li&gt;
&lt;li&gt;Copiar el fichero anterior al directorio personal.&lt;/li&gt;
&lt;li&gt;Eliminar el fichero original.&lt;/li&gt;
&lt;li&gt;Reinicia el sistema operativo.&lt;/li&gt;
&lt;li&gt;Bloquea la sesión de tu usuario y vuelve a entrar en ella&lt;/li&gt;
&lt;li&gt;Añade un nuevo usuario al sistema&lt;/li&gt;
&lt;li&gt;Sal de tu usuario actual y entra como el nuevo usuario&lt;/li&gt;
&lt;li&gt;Cambiar el password del nuevo usuario&lt;/li&gt;
&lt;li&gt;Configura el protector de pantalla para que se inicie a los 10 minutos de inactividad&lt;/li&gt;
&lt;li&gt;Modifica los ajustes de la aplicación terminal para que el tipo de letra tenga un tamaño de 11 puntos&lt;/li&gt;
&lt;li&gt;Ancla la aplicación terminal a la barra de aplicaciones y desancla el editor de hojas de cálculo LibreOffice&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;la-terminal-de-unix&#34;&gt;La terminal de UNIX&lt;/h1&gt;

&lt;p&gt;La &lt;a href=&#34;https://en.wikipedia.org/wiki/Command-line_interface&#34; target=&#34;_blank&#34;&gt;Shell&lt;/a&gt; (o terminal) es un interprete de comandos. Es simplemente un modo alternativo de controlar un ordenador basado en una interfaz de texto. La terminal nos permite ejecutar software escribiendo el nombre del programa que queremos ejecutar en la terminal. Podemos pedirle al ordenador que ejecute un programa mediante el ratón ciclando en distintos lugares del escritorio o podemos escribir una orden para conseguir el mismo objetivo. Por ejemplo, para pedirle al ordenador que nos de una lista de los archivos presentes en un directorio podemos abrir un navegador de archivos o podemos escribir en la terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls folder_name
file_1.txt
file_2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ninguna de las dos formas de comunicarse con el ordenador es mejor que la otra aunque en ciertas ocasiones puede resultar más conveniente utilizar una u otra Las ventajas de la línea de comandos son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Necesidad. Existe mucho software que está sólo disponible en la terminal. Esto es especialmente cierto en el área de la bioinformática.&lt;/li&gt;
&lt;li&gt;Flexibilidad. Los programas gráficos suelen ser muy adecuados para realizar la tarea para la que han sido creados, pero son difíciles de adaptar para otras tareas. Los programas diseñados para ser usados en la línea de comandos suelen ser muy versátiles.&lt;/li&gt;
&lt;li&gt;Reproducibilidad. Documentar y repetir el proceso seguido para realizar un análisis con un programa gráfico es muy costoso puesto que es difícil describir la secuencia de clicks y doble clicks que hemos realizado. Por el contrario, los procesos realizados mediante la línea de comandos son muy fáciles de documentar puesto que tan sólo debemos guardar el texto que hemos introducido en la pantalla.&lt;/li&gt;
&lt;li&gt;Fiabilidad. Los programas básicos de Unix fueron creados en los años 70 y han sido probados por innumerables usuarios por lo que se han convertido en piezas de código extraordinariamente confiables.&lt;/li&gt;
&lt;li&gt;Recursos. Las interfaces gráficas suelen consumir muchos recursos mientras que los programas que funcionan en línea de comandos suelen ser extraordinariamente livianos y rápidos. Este poco uso de recursos facilita, por ejemplo, que se utilice a través de la red.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El problema de la terminal es que para poder utilizarla debemos saber previamente qué queremos hacer y cómo. Es habitual descubrir como funciona un programa con una interfaz gráfica sin tener que leer un manual, esto no sucede en la terminal.&lt;/p&gt;

&lt;p&gt;Para usar la línea de comandos hay que abrir una terminal. Se abrirá una terminal con un mensaje similar a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usuario $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este pequeño mensaje se denomina &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Command-line_interface#Command_prompt&#34; target=&#34;_blank&#34;&gt;prompt&lt;/a&gt;&lt;/em&gt; y el cursor parpadeante que aparece junto al él indica que el ordenador está esperando una orden. El mensaje exacto que aparece en el &lt;em&gt;prompt&lt;/em&gt; puede variar ligeramente, pero en Ubuntu suele ser similar a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usuario@ordenador:~/documentos$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En el &lt;em&gt;prompt&lt;/em&gt; de Ubuntu se nos muestra el nombre del usuario, el nombre del ordenador y el directorio en el que nos encontramos actualmente, es decir, el directorio de trabajo actual.&lt;/p&gt;

&lt;p&gt;Cuando el &lt;em&gt;prompt&lt;/em&gt; se muestra podemos ejecutar cualquier cosa, por ejemplo le podemos pedir que liste los ficheros mediante el comando &lt;em&gt;ls&lt;/em&gt; (LiSt)::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usuario $ ls
lista_libros.txt
rectas_cocina/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;ls&lt;/em&gt;, como cualquier otro comando, es en realidad un programa que el ordenador ejecuta. Cuando escribimos la orden (y pulsamos enter) el programa se ejecuta. Mientras el programa está ejecutándose el &lt;em&gt;prompt&lt;/em&gt; desaparece y no podemos ejecutar ningún otro comando. Pasado el tiempo el programa termina su ejecución y el &lt;em&gt;prompt&lt;/em&gt; vuelve a aparecer. En el caso del comando &lt;em&gt;ls&lt;/em&gt; el tiempo de ejecución es tan pequeño que suele ser imperceptible.&lt;/p&gt;

&lt;p&gt;Los programas suelen tener unas entradas y unas salidas. Dependiendo del caso estas pueden ser ficheros o caracteres introducidos o impresos en la pantalla. Por ejemplo, el resultado de &lt;em&gt;ls&lt;/em&gt; es simplemente una lista impresa de ficheros y directorios en la interfaz de comandos.&lt;/p&gt;

&lt;p&gt;Normalmente el comportamiento de los programas puede ser modificado pasándoles parámetros. Por ejemplo, podríamos pedirle al programa &lt;em&gt;ls&lt;/em&gt; que nos imprima una lista de ficheros más detallada escribiendo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ayuda&#34;&gt;Ayuda&lt;/h2&gt;

&lt;p&gt;Cada comando tiene unos parámetros y opciones distintos. La forma estándar de pedirles que nos enseñen cuales son estos parámetros suele ser utilizar las opciones ‘–help’, ‘-h’ o ‘-help’, aunque esto puede variar en comandos no estándar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls --help
Modo de empleo: ls [OPCIÓN]... [FICHERO]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otro modo de acceder a una documentación más detallada es acceder al manual del programa utilizando el comando &lt;em&gt;man&lt;/em&gt; (MANual):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ man ls
(para terminar pulsar &amp;quot;q&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;man&lt;/em&gt; es un programa interactivo, cuando ejecutamos el comando el programa se abre y el &lt;em&gt;prompt&lt;/em&gt; desaparece. &lt;em&gt;man&lt;/em&gt; es en realidad un visor de ficheros de texto por lo que cuando lo ejecutamos la pantalla se rellena con la ayuda del programa que hemos solicitado. Podemos ir hacia abajo o hacia arriba y podemos buscar en el contenido de la ayuda. El &lt;em&gt;prompt&lt;/em&gt; y la posibilidad de ejecutar otro programa no volverán a aparecer hasta que no cerremos el programa interactivo. En el caso de man para cerrar el programa hay que pulsar la tecla “q”.&lt;/p&gt;

&lt;h2 id=&#34;completado-automático-e-historia&#34;&gt;Completado automático e historia&lt;/h2&gt;

&lt;p&gt;El intérprete de comandos dispone de algunas utilidades para facilitarnos su uso. Una de las más utilizadas es el completado automático. Podemos evitarnos escribir una gran parte de los comandos haciendo uso de la tecla tabulador. Si empezamos a escribir un comando y pulsamos la tecla tabulador el sistema completará el comando por nosotros. Para probarlo creemos los ficheros datos_1.txt, datos_2.txt y tesis.txt::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ touch datos_1.txt
~$ touch datos_2.txt
~$ touch experimento.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si ahora empezamos a escribir &lt;em&gt;cp e&lt;/em&gt; y pulsamos el tabulador dos veces, el intérprete de comandos completará el comando automáticamente::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp e
~$ cp experimento.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si el intérprete encuentra varias alternativas completará el comando hasta el punto en el que no haya ambigüedad. Si deseamos que imprima una lista de todas las alternativas disponibles para continuar con el comando deberemos pulsar el tabulador dos veces.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp d
$ cp datos_
datos_1.txt  datos_2.txt
~$ cp datos_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otra de las funcionalidades que más nos pueden ayudar es la historia. El intérprete recuerda todos los comandos que hemos introducido anteriormente. Si queremos podemos obtener una lista de todo lo que hemos ejecutado utilizando el comando history. Pero lo más socorrido es simplemente utilizar los cursores arriba y abajo para revisar los comandos anteriores. Otra forma de acceder a la historia es utilizar la combinación de teclas control y r. De este modo podemos buscar comandos antiguos sencillamente.&lt;/p&gt;

&lt;h2 id=&#34;ejercicio&#34;&gt;Ejercicio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lista todos los comandos que empiezan por apt&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bibliografía&#34;&gt;Bibliografía&lt;/h1&gt;

&lt;p&gt;Existen numerosas fuentes sobre la historia y la filosofía de Unix, de Linux y del software libre. Entre ellas se encuentran:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Las páginas de la wikipedia sobre: &lt;a href=&#34;http://es.wikipedia.org/wiki/Unix&#34; target=&#34;_blank&#34;&gt;Unix&lt;/a&gt;, &lt;a href=&#34;http://es.wikipedia.org/wiki/Linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;, &lt;a href=&#34;http://es.wikipedia.org/wiki/Ubuntu&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt; y [software libre](&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/&#34; target=&#34;_blank&#34;&gt;https://bioinf.comav.upv.es/courses/unix/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Rebel-Code-Linux-Source-Revolution/dp/0738203335&#34; target=&#34;_blank&#34;&gt;Rebel Code&lt;/a&gt;, un libro de Glyn Moody dedicado a la historia del movimiento del software libre.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oreilly.com/catalog/9780596001087&#34; target=&#34;_blank&#34;&gt;La catedral y el bazar&lt;/a&gt; de Eric S. Raymond. Un ensayo sobre los beneficios del modelo de desarrollo asociados al software libre.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://catb.org/~esr/writings/taoup/&#34; target=&#34;_blank&#34;&gt;The Art of Unix Programming&lt;/a&gt; (&lt;a href=&#34;https://bioinf.comav.upv.es/documentacion/bibliography/the_art_of_unix_programming.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt; de Eric S. Raymond. Dedicado a la filosofía de los sistemas Unix.&lt;/li&gt;
&lt;li&gt;El excelente [Ubuntu manual](&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/&#34; target=&#34;_blank&#34;&gt;https://bioinf.comav.upv.es/courses/unix/&lt;/a&gt; [pdf](&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/&#34; target=&#34;_blank&#34;&gt;https://bioinf.comav.upv.es/courses/unix/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;La documentación &lt;a href=&#34;https://help.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;oficial&lt;/a&gt; y de la &lt;a href=&#34;https://help.ubuntu.com/community&#34; target=&#34;_blank&#34;&gt;comunidad&lt;/a&gt; de Ubuntu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hay varios cursos para iniciarse en el uso de la línea de comandos de Unix, como:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.flossmanuals.net/gnulinux&#34; target=&#34;_blank&#34;&gt;Put Yourself in Command&lt;/a&gt; de la Free Software Fundation, copia en &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/documentacion/fsf_cmd_manual.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxcommand.org/learning_the_shell.php&#34; target=&#34;_blank&#34;&gt;Learning the shell&lt;/a&gt; de &lt;a href=&#34;http://linuxcommand.org/lc3_learning_the_shell.php&#34; target=&#34;_blank&#34;&gt;Linuxcommand.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rlworkman.net/howtos/rute/&#34; target=&#34;_blank&#34;&gt;Rute User’s Tutorial and Exposition&lt;/a&gt; de Paul Sheer, copia en &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/documentacion/rute.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oreilly.com/catalog/9780596002619&#34; target=&#34;_blank&#34;&gt;Learning the Unix Operating System&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Procesamiento texto</title>
      <link>https://www.marcusrb.com/unix/05-procesamiento-texto/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/05-procesamiento-texto/</guid>
      <description>

&lt;h1 id=&#34;procesamiento-de-ficheros-de-texto&#34;&gt;Procesamiento de ficheros de texto&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#ficheros-de-texto-y-binarios&#34; target=&#34;_blank&#34;&gt;Ficheros de texto y binarios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#editores-de-texto&#34; target=&#34;_blank&#34;&gt;Editores de texto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#imprimiendo-ficheros-cat-head-y-tail&#34; target=&#34;_blank&#34;&gt;Imprimiendo ficheros &lt;em&gt;cat&lt;/em&gt;, &lt;em&gt;head&lt;/em&gt; y &lt;em&gt;tail&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#navegando-por-un-fichero-de-texto&#34; target=&#34;_blank&#34;&gt;Navegando por un fichero de texto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Edición por línea de comandos

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#wc&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;wc&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#grep&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;grep&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#cut&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;cut&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#sed&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;sed&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#sort&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;sort&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#uniq&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;uniq&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#shuf&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;shuf&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Herramientas para unir archivos

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#paste&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;paste&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#join&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;join&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#codificacin-de-caracteres&#34; target=&#34;_blank&#34;&gt;Codificación de caracteres&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#fin-de-lnea&#34; target=&#34;_blank&#34;&gt;Fin de línea&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#soluciones&#34; target=&#34;_blank&#34;&gt;Soluciones&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/procesamiento_texto.html#bibliografa&#34; target=&#34;_blank&#34;&gt;Bibliografía&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Uno de los puntos fuertes de los sistemas Unix estriba en la  facilidad con la que pueden analizar los ficheros de texto en ellos. Estos sistemas incluyen una serie de herramientas que permiten realizar  una gran cantidad de manipulaciones en estos ficheros sin necesidad de  instalar ninguna herramienta especializada.&lt;/p&gt;

&lt;p&gt;En esta sección vamos a presentar varias de estas herramientas. Trabajaremos con el siguiente &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/microarray_adenoma_hk69.ods&#34; target=&#34;_blank&#34;&gt;archivo de prueba&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;ficheros-de-texto-y-binarios&#34;&gt;Ficheros de texto y binarios&lt;/h2&gt;

&lt;p&gt;Antes de comenzar a analizar los este tipo de ficheros debemos aclarar qué es y qué no es un &lt;a href=&#34;https://en.wikipedia.org/wiki/Text_file&#34; target=&#34;_blank&#34;&gt;fichero de texto&lt;/a&gt;. Un fichero de texto es un fichero dividido en líneas y cuyo contenido es exclusivamente &lt;a href=&#34;https://en.wikipedia.org/wiki/Plain_text&#34; target=&#34;_blank&#34;&gt;texto simple&lt;/a&gt;, es decir, sólo hay caracteres alfanuméricos (letras y números),  retornos de carro y tabuladores. Los ficheros de texto pueden ser abiertos e inspeccionados sin necesidad de hacer uso de un software especial diseñado para trabajar con ellos.&lt;/p&gt;

&lt;p&gt;A pesar de lo que pudiese parecer a priori, los documento de  Microsoft Office o de LibreOffice no son ficheros de texto, contienen  otras cosas como información de formato, estilo, tablas o imágenes. La información contenida en estos documentos es binaria y sólo los  programas especialmente creados para abrir estos ficheros pueden acceder a ella de un modo inteligible.&lt;/p&gt;

&lt;p&gt;Uno de los puntos fundamentales de la filosofía Unix, es la  utilización de ficheros de texto. Mientras otros sistemas operativos favorecen la utilización de ficheros  binarios, que deben ser acompañados de herramientas especiales para  poder manipularlos, en Unix se optó por crear un conjunto de  herramientas para manipulación de ficheros de texto y por utilizar para  los ficheros del sistema sólo ficheros de texto siempre que esto fuese  posible.&lt;/p&gt;

&lt;h2 id=&#34;editores-de-texto&#34;&gt;Editores de texto&lt;/h2&gt;

&lt;p&gt;En Linux existen editores de texto que funcionan con entorno gráfico, como el &lt;em&gt;gedit&lt;/em&gt;, &lt;em&gt;KWrite&lt;/em&gt; o &lt;em&gt;Leafpad&lt;/em&gt;, y editores que funcionan en la terminal, como el &lt;em&gt;nano&lt;/em&gt;, &lt;em&gt;pico&lt;/em&gt; o &lt;em&gt;vim&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;vim&lt;/em&gt; es un editor de texto potente y versátil pero dominar su manejo requiere bastante tiempo.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;nano&lt;/em&gt; es una versión mejorada de &lt;em&gt;pico&lt;/em&gt;. Se trata de un editor simple y versátil pero mucho más fácil de usar que, por ejemplo, &lt;em&gt;vim&lt;/em&gt; y está instalado por defecto en muchas distribuciones de Linux.&lt;/p&gt;

&lt;p&gt;Vamos a ver cómo usar nano para crear o modificar archivos de texto, así como alguna de sus funcionalidades.&lt;/p&gt;

&lt;p&gt;Podemos abrir &lt;em&gt;nano&lt;/em&gt; directamente y se abrirá con un archivo vacio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ nano
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;o bien indicarle la dirección de un archivo. En el caso que el archivo no exista lo creará.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ nano nombre_archivo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En la parte superior indica la versión y el nombre del archivo y en  la parte superior se muestran algunas de las opciones del editor. Si  deseamos ver una lista más completa podemos acceder a la ayuda mediante &lt;em&gt;Ctrl + g&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Crtl + x :       Cerrar el fichero / Salir de nano&lt;/li&gt;
&lt;li&gt;Crtl + o :       Guardar&lt;/li&gt;
&lt;li&gt;Alt + u :       Deshacer&lt;/li&gt;
&lt;li&gt;Alt + e :        Rehacer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nos podemos mover por el documento con los cursores, y los botones de inicio, fin y avance y retroceso de página.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Alt + a :        Seleccionar texto desde la posición actual del cursor&lt;/li&gt;
&lt;li&gt;Alt +  6 :       Copiar selección o línea actual&lt;/li&gt;
&lt;li&gt;Crtl + k :       Cortar selección o línea actual&lt;/li&gt;
&lt;li&gt;Crtl + u :       Pegar&lt;/li&gt;
&lt;li&gt;Alt +  w :      Buscar una cadena de texto o expresión regular&lt;/li&gt;
&lt;li&gt;Crtl + \ :        Buscar y reemplazar una cadena de texto o expresión regular&lt;/li&gt;
&lt;li&gt;Crtl + t :       Invocar el corrector ortográfico (requiere tener instalado &lt;em&gt;spell&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Alt + d :        Contar el número de palabras, líneas y caracteres&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;imprimiendo-ficheros-cat-head-y-tail&#34;&gt;Imprimiendo ficheros &lt;em&gt;cat&lt;/em&gt;, &lt;em&gt;head&lt;/em&gt; y &lt;em&gt;tail&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;A veces, si los archivos son muy grandes incluso los editores en línea pueden tener problemas para abrirlos. Otra forma de acceder a los contenidos del fichero sería imprimir el fichero en la terminal utilizando el comando &lt;em&gt;cat&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ cat microarray_adenoma_hk69.ods
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recuerda que las herramientas que estamos viendo sólo sirven para trabjar con ficheros de texto, no binarios.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ cat microarray_adenoma_hk69.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si el archivo es extremadamente largo es posible que la terminal se bloquee durante bastante tiempo (Nota: recuerda que con &lt;em&gt;Crtl + c&lt;/em&gt; los programas suelen terminar inmediatamente y se vuelve a mostrar el &lt;em&gt;prompt&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;cat&lt;/em&gt; es además capaz de concatenar textos uno detrás de otro en el orden en que se los pasamos y mostrarlos en pantalla&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ cat file1 file2 file3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Algunas opciones interesantes de &lt;em&gt;cat&lt;/em&gt; son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-A : muestra también los caracteres de control, básicamente los tabuladores (como ^I) y los retornos de carro ($)&lt;/li&gt;
&lt;li&gt;-n : numera todas las líneas&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para hacernos una idea del contenido del fichero sin bloquear la  terminal podemos imprimir tan solo las primeras líneas utilizando el  comando &lt;em&gt;head&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ head microarray_adenoma_hk69.csv
  &amp;quot;!Exptid=10029&amp;quot;
  &amp;quot;!Experiment Name=Adenoma (HK69)&amp;quot;
  &amp;quot;!Organism=Homo sapiens&amp;quot;
  &amp;quot;!Category=Adenoma&amp;quot;
  &amp;quot;!Subcategory=Liver&amp;quot;
  &amp;quot;!Experimenter=Xin Chen&amp;quot;
  &amp;quot;!Contact email=chenx@pharmacy.ucsf.edu&amp;quot;
  &amp;quot;!Contact Address1=Dept. of Biopharmaceutical Sciences&amp;quot;
  &amp;quot;!Contact Address2=513 Parnassus Ave. S-816&amp;quot;
  &amp;quot;!Contact Address3=Box 0446&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existe otro comando equivalente pero que nos permite imprimir el final de los archivos (&lt;em&gt;tail&lt;/em&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ tail microarray_adenoma_hk69.csv
  24183       &amp;quot;EMPTY&amp;quot; &amp;quot;EMPTY&amp;quot; 19      27      32      0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tanto a &lt;em&gt;head&lt;/em&gt; como a &lt;em&gt;tail&lt;/em&gt; podemos pedirles que impriman el número de líneas que nosotros deseemos mediante la opción &lt;em&gt;-n&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ head -n 2 microarray_adenoma_hk69.csv
  &amp;quot;!Exptid=10029&amp;quot;
  &amp;quot;!Experiment Name=Adenoma (HK69)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otro comportamiento de &lt;em&gt;tail&lt;/em&gt; que resulta útil es que puede mostrar todas las líneas excepto las &lt;em&gt;k&lt;/em&gt; primeras líneas. Para ello hay que usar la opción &lt;em&gt;-n&lt;/em&gt; y el número de líneas que queremos omitir precedido por un &lt;em&gt;+&lt;/em&gt;. Por ejemplo, para omitir la cabecera del archivo de micro_adenoma que ocupa las primeras 20 líneas podemos hacer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ tail -n +20 microarray_adenoma_hk69.csv  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;navegando-por-un-fichero-de-texto&#34;&gt;Navegando por un fichero de texto&lt;/h2&gt;

&lt;p&gt;En muchas ocasiones para familiarizarnos con el fichero lo mejor es abrirlo y navegar por él. Podríamos abrir el fichero con un editor de texto, pero ya hemos visto que si es muy grande podríamos tener problemas. Existe una herramienta capaz de abrir ficheros de texto inmensos sin problemas, &lt;em&gt;less&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;less&lt;/em&gt; es un visor de ficheros de texto, con este programa no podremos editar el fichero, pero sí navegar por su contenido. &lt;em&gt;less&lt;/em&gt; es un programa interactivo por lo que cuando lo ejecutemos se abrirá ocupando el terminal y haciendo desaparecer el &lt;em&gt;prompt&lt;/em&gt;. En cualquier momento podemos salir de &lt;em&gt;less&lt;/em&gt; pulsando la tecla “q”.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ less microarray_adenoma_hk69.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dentro de &lt;em&gt;less&lt;/em&gt; disponemos de varios comandos para movernos por el fichero:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;barra de espacio: página siguiente.&lt;/li&gt;
&lt;li&gt;b: página anterior.&lt;/li&gt;
&lt;li&gt;100g: va a la línea 100 (o la que le indiquemos)&lt;/li&gt;
&lt;li&gt;-S: corta o no corta las líneas largas&lt;/li&gt;
&lt;li&gt;/palabra: Busca la cadena de texto que le indiquemos (acepta expresiones regulares)&lt;/li&gt;
&lt;li&gt;n: va a la siguiente palabra que coincide con la búsqueda&lt;/li&gt;
&lt;li&gt;N: va la palabra anterior que coincide con la búsqueda&lt;/li&gt;
&lt;li&gt;q: sale del programa&lt;/li&gt;
&lt;li&gt;h: ayuda&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;edición-por-línea-de-comandos&#34;&gt;Edición por línea de comandos&lt;/h2&gt;

&lt;h3 id=&#34;wc&#34;&gt;&lt;em&gt;wc&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;wc&lt;/em&gt; (&lt;em&gt;Word Count&lt;/em&gt;) sirve para contar líneas, palabras y caracteres.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ wc leukemia microarray_adenoma_hk69.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grep&#34;&gt;&lt;em&gt;grep&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Una tarea que vamos a tener que realizar habitualmente es la de seleccionar diversas líneas en un fichero de texto. Por ejemplo, imaginemos que queremos saber cual es la expresión de los genes relacionados con la leucemia en el fichero del &lt;em&gt;microarray&lt;/em&gt;. Esto, que en otros sistemas operativos podría resultar bastante complejo de hacer en Unix es trivial:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep leukemia microarray_adenoma_hk69.csv
  3       &amp;quot;IMAGE:302190&amp;quot;  &amp;quot;MLL&amp;quot;   &amp;quot;Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;grep&lt;/em&gt; (&lt;em&gt;Generalized Regular Expression Parser&lt;/em&gt;) toma un fichero de entrada (o el &lt;em&gt;standard  input&lt;/em&gt;) y filtra las líneas que contienen el patrón de búsqueda que le hemos  dado. Por defecto incluye en el resultado las líneas que contienen el  patrón, pero podríamos pedirle que haga lo contrario utilizando la  opción &lt;em&gt;v&lt;/em&gt; (&lt;em&gt;inVert&lt;/em&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ grep -v leukemia microarray_adenoma_hk69.csv
  3       &amp;quot;IMAGE:302190&amp;quot;  &amp;quot;MLL&amp;quot;   &amp;quot;Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;grep&lt;/em&gt; diferencia entre mayúsculas y minúsculas, pero podemos cambiar este comportamiento con la opción &lt;em&gt;i&lt;/em&gt; (ignore case):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ grep -i leukemia microarray_adenoma_hk69.csv
  3       &amp;quot;IMAGE:302190&amp;quot;  &amp;quot;MLL&amp;quot;   &amp;quot;Myeloid/lymphoid or mixed-lineage leukemia (trithorax homolog, Drosophila)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si queremos saber en que posiciones del fichero original estaban las  líneas que hemos encontrado podemos pedirle que imprima dichos números  de línea:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -n leukemia microarray_adenoma_hk69.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;grep&lt;/em&gt; puede utilizarse para buscar recursivamente en todos los ficheros contenidos en un directorio. Por ejemplo podríamos buscar la palabra &lt;em&gt;leukemia&lt;/em&gt; en todos los ficheros presentes en alguno de nuestros directorios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -r  leukemia ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;grep&lt;/em&gt; tiene otras muchas opciones útiles, en su manual están todas descritas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ man grep
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;grep&lt;/em&gt; hace uso de las expresiones regulares que veremos  posteriormente por lo que su potencia es mucho mayor que la que ahora  podemos imaginar.&lt;/p&gt;

&lt;p&gt;Otra de las ventajas de &lt;em&gt;grep&lt;/em&gt; viene dada por su adherencia a los principios Unix lo que implica que podemos utilizar &lt;em&gt;grep&lt;/em&gt; enlazándolo con otros programas. Imaginemos que queremos hacer una búsqueda limitada a las primeras cien líneas del fichero, podríamos hacer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lo que hemos hecho es utilizar el comando &lt;em&gt;head&lt;/em&gt; para leer las primeras cien líneas del archivo, pero en vez de imprimir el resultado  en pantalla hemos redirigido su salida mediante una tubería (&lt;em&gt;pipe&lt;/em&gt;) al comando &lt;em&gt;grep&lt;/em&gt;. Éste ha tomado estas cien líneas y las ha filtrado con la palabra &lt;em&gt;leukemia&lt;/em&gt;. Podríamos además redirigir el resultado final a un fichero para guardar el resultado:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia &amp;gt; busqueda_leukemia_100.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;o bien pasárselo a otro programa, por ejemplo, a &lt;em&gt;wc&lt;/em&gt; para que cuente el número de veces que aparece &lt;em&gt;leukemia&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ head -n 100 microarray_adenoma_hk69.csv | grep leukemia | wc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Todos los comandos de manejo de texto que vamos a ver en esta sección tienen esta capacidad. Todos siguen el principio de realizar una tarea concreta pero teniendo la capacidad de enlazarse con otros.&lt;/p&gt;

&lt;h3 id=&#34;cut&#34;&gt;&lt;em&gt;cut&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Cuando el fichero está dividido en campos, como en el caso de la  tabla que estamos utilizando, podemos seleccionar alguno de estos campos utilizando el comando &lt;em&gt;cut&lt;/em&gt;. Por ejemplo mejoremos la búsqueda que habíamos hecho quedándonos tan solo con el nombre del gen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3
 &amp;quot;BAALC&amp;quot;
 &amp;quot;DEK&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con el parámetro &lt;em&gt;-f&lt;/em&gt; le indicamos la lista de campos (&lt;em&gt;fields&lt;/em&gt;) que queremos seleccionar.&lt;/p&gt;

&lt;p&gt;Para indicar los campos que queremos seleccionar:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N : el campo N (p.e., cut -f 3 file1)&lt;/li&gt;
&lt;li&gt;N- : desde el campo N hasta el final (p.e., cut -f 3- file1)&lt;/li&gt;
&lt;li&gt;N-M : desde el campo N al M (p.e., cut -f 3-6 file1)&lt;/li&gt;
&lt;li&gt;-M : desde el primer campo al campo M (p.e., cut -f -3 file1)&lt;/li&gt;
&lt;li&gt;N,M : los campos indicados (p.e., cut -f 3,6,8 file1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Así podríamos seleccionar los campos del 3 al 5 y del 8 al 10:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ cut -f 3-5,8-10 microarray_adenoma_hk69.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;cut&lt;/em&gt; asume que los campos en el fichero están divididos por tabuladores. Pero podríamos indicarle que los campos están divididos de otro modo, por ejemplo por comas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ cut -d &#39;,&#39; fichero_separado_por_comas.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para tener una idea completa de las capacidades ofrecidas por el comando conviene consultar su manual:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ man cut
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sed&#34;&gt;&lt;em&gt;sed&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;El &lt;em&gt;sed&lt;/em&gt; (&lt;em&gt;stream editor&lt;/em&gt;) es un editor de texto un tanto especial que toma las líneas de una en una, les aplica la transformación que le indiquemos y devuelve las líneas modificadas.&lt;/p&gt;

&lt;p&gt;Por ejemplo, la lista de genes que hemos obtenido en el apartado  anterior puede servirnos para muchos propósitos, pero todavía no está  limpia del todo, quedaría mejor si eliminásemos las comillas que rodean  los campos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4 | sed  &amp;quot;s/\&amp;quot;//g&amp;quot;
  BAALC   Brain and acute leukemia, cytoplasmic
  DEK     DEK oncogene (DNA binding)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El &lt;em&gt;sed&lt;/em&gt; además de sustituir puede realizar cualquier tipo de edición sobre un texto. La sintaxis utilizada por &lt;em&gt;sed&lt;/em&gt; puede resultar algo oscura al  principio, pero un mínimo conocimiento de este comando nos permitirá  hacer modificaciones en el texto que de otro modo serían muy complejas.&lt;/p&gt;

&lt;p&gt;En este curso nos centraremos en el uso del &lt;em&gt;sed&lt;/em&gt; para sustituciones. En el ejemplo anterior, el comando sed que hemos utilizado es “s/&amp;ldquo;//g”. En primer lugar hemos indicado a &lt;em&gt;sed&lt;/em&gt; qué queríamos hacer. Podemos, como es el caso, substituir un patrón por otro (comando s,  sustituir), pero también podríamos pedirle que eliminase líneas (comando d, delete). Para substituir hay que indicarle qué queremos substituir y por qué:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  s/patrón_a_substituir/nuevo_patrón/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En el ejemplo hemos substituido las comillas por nada. En principio deberíamos haber escrito “s/”//”. Pero dado que las comillas tienen un significado especial en este contexto debemos &lt;em&gt;escaparlas&lt;/em&gt;, por eso escribimos “s/\”//”. Además, a la expresión le hemos añadido una “g”, con este modificador le indicamos a &lt;em&gt;sed&lt;/em&gt; que no queremos que substituya sólo la primera aparición del patrón en la línea sino todos los que haya.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sed&lt;/em&gt; acepta expresiones regulares como patrones y con ellas  puede realizar prácticamente cualquier substitución que podamos  imaginar.&lt;/p&gt;

&lt;h3 id=&#34;sort&#34;&gt;&lt;em&gt;sort&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Si deseamos ordenar alfabéticamente un fichero de texto tan sólo tenemos que utilizar el comando &lt;em&gt;sort&lt;/em&gt;. Por ejemplo, podemos ordenar los genes relacionados con la leucemia:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4| sort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;sort&lt;/em&gt; también puede hacer ordenaciones numéricas y puede ordenar por cualquiera de los campos presentes en el fichero. Para ver qué se puede hacer con &lt;em&gt;sort&lt;/em&gt; lo más recomendable es leer su manual.&lt;/p&gt;

&lt;h3 id=&#34;uniq&#34;&gt;&lt;em&gt;uniq&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;En el ejemplo anterior, al ordenar con &lt;em&gt;sort&lt;/em&gt;, hemos visto que en la lista que hemos obtenido hay genes repetidos. Con el comando &lt;em&gt;uniq&lt;/em&gt; podemos eliminar las líneas duplicadas consecutivas. Para que la eliminación sea completa hay que recordad ordenar con &lt;em&gt;sort&lt;/em&gt; antes de utilizar &lt;em&gt;uniq&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4| sort | uniq
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;shuf&#34;&gt;&lt;em&gt;shuf&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;shuf&lt;/em&gt; permite obtener permutaciones aleatorias del archivo de entrada, o bien obtener líneas aleatorias.&lt;/p&gt;

&lt;p&gt;Si no le pasamos ningún parámeto a &lt;em&gt;shuf&lt;/em&gt; obtendremos permutaciones aleatorias:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ ls / | shuf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;o bien le podemos pedir el número de líneas aleatorias que deseemos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep leukemia microarray_adenoma_hk69.csv | cut -f 3,4 | shuf -n 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;herramientas-para-unir-archivos&#34;&gt;Herramientas para unir archivos&lt;/h2&gt;

&lt;h3 id=&#34;paste&#34;&gt;&lt;em&gt;paste&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;paste&lt;/em&gt; une ficheros tabulares línea por línea. Supongamos que tenemos dos ficheros, uno con datos sobre la progresión  de la enfermedad de una serie de enfermos y otro con el genotipado de  los mismos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  pacientes:
  id_paciente,nivel_colesterol
  1,190
  2,250
  3,220
  4,260
  5,160
  genotipado:
  id_paciente,SNP_a,SNP_b
  1,AA,CC
  2,AC,GG
  3,AA,CG
  4,AT,GG
  5,AA,CC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos fusionar los dos archivos usando el comando paste:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ paste -d&#39;,&#39; pacientes.txt genotipado.txt
  id_paciente,nivel_colesterol,id_paciente,SNP_a,SNP_b
  1,190,1,AA,CC
  2,250,2,AC,GG
  3,220,3,AA,CG
  4,260,4,AT,GG
  5,160,5,AA,CC
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;join&#34;&gt;&lt;em&gt;join&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;join&lt;/em&gt; es una herramienta muy potente, pero sencilla. Permite  unir dos ficheros de texto en uno usando una columna como clave común.  Por defecto, &lt;em&gt;join&lt;/em&gt; asume que el separador de campos es el espacio.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;join&lt;/em&gt; es una especie de &lt;em&gt;paste&lt;/em&gt; en la que la columna  común que sirve como enlace entre ambas tablas no queda duplicada y no  requiere que un elemento esté en los dos archivos. &lt;em&gt;join&lt;/em&gt; lo que sí que requiere es que ambos archivos estén ordenados por la columna que se queiere usar como clave Imaginemos que tenemos los dos ficheros siguientes: &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/file1.txt&#34; target=&#34;_blank&#34;&gt;file1.txt&lt;/a&gt; y &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/file2.txt&#34; target=&#34;_blank&#34;&gt;file2.txt&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  file1.txt:
  num id atributo
  1 abc fff
  2 efg aaa
  5 klm bbb
  file2.txt:
  num id atributo
  1 abc ttt
  3 klm fff
  5 opq jjj
  9 rst ttt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;join&lt;/em&gt; nos permite unir estas dos tablas en una sola utilizando el campo &lt;em&gt;num&lt;/em&gt; como la clave de unión:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ join file1.tx file2.tx
  num id atributo id atributo
  1 abc fff abc ttt
  5 klm bbb opq jjj 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por defecto, &lt;em&gt;join&lt;/em&gt; asume que la clave de unión es la primera columna, pero esto se puede modificar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ join -1 2 -2 2 file1.tx file2.tx
  id num atributo num atributo
  abc 1 fff 1 ttt
  klm 5 bbb 3 fff
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las filas que no son comunes entre ambos archivos no se devuelven por defecto, pero esto también es modificable y podemos solicitar que nos  devuelva todas las de un archivo, las del otro o las de los dos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ join -a1 -1 2 -2 2 file1.tx file2.tx
  id num atributo num atributo
  abc 1 fff 1 ttt
  efg 2 aaa
  klm 5 bbb 3 fff
  ~$ join -a1 -a2 -1 2 -2 2 file1.tx file2.tx
  id num atributo num atributo
  abc 1 fff 1 ttt
  efg 2 aaa
  klm 5 bbb 3 fff
  opq 5 jjj
  rst 9 ttt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;codificación-de-caracteres&#34;&gt;Codificación de caracteres&lt;/h2&gt;

&lt;p&gt;Los ordenadores codifican los caracteres del lenguaje natural  utilizando números. Los ficheros de texto no son pues más que ficheros de números que el  ordenador transforma en caracteres utilizando una tabla de codificación  de caracteres antes de imprimirlos. Una de las tablas de codificación más populares es la &lt;a href=&#34;https://es.wikipedia.org/wiki/ASCII&#34; target=&#34;_blank&#34;&gt;ASCII&lt;/a&gt;, en ella se incluyen los caracteres utilizados en la lengua inglesa,  pero no los acentos o los caracteres de otros alfabetos. Para solucionar el problema el ASCII original fue ampliado creándose  distintas tablas, una por cada lengua natural. De este modo con el ASCII correspondiente al castellano podemos crear  ficheros de texto con acentos. Pero al crear distintas tablas de codificación surgió un problema, si  nos equivocamos de tabla al decodificar el fichero obtendremos  caracteres extraños que no se corresponden con lo que originalmente se  había escrito. Para solucionar el problema se creó la norma &lt;a href=&#34;https://es.wikipedia.org/wiki/Unicode&#34; target=&#34;_blank&#34;&gt;Unicode&lt;/a&gt;, que es una gran tabla con unos 100713 símbolos que codifican  prácticamente todos los caracteres utilizados en casi cualquier alfabeto humano.&lt;/p&gt;

&lt;p&gt;El problema práctico al que nos enfrentamos es que para poder abrir  un fichero de texto que incluya caracteres no ingleses debemos conocer  la tabla de caracteres en la que fue codificado. En Linux los ficheros de texto se codifican mediante &lt;em&gt;UTF-8&lt;/em&gt; que es una de las tablas del estándar &lt;em&gt;Unicode&lt;/em&gt;, pero en &lt;em&gt;Windows&lt;/em&gt; no se sigue este estándar. Las instalaciones de Windows en castellano utilizan la tabla Windows-1252.&lt;/p&gt;

&lt;p&gt;Normalmente los editores de texto permiten elegir la tabla de  caracteres en la que el fichero ha sido codificado. Si abrimos un fichero y vemos que tiene símbolos raros lo más normal es  que estemos utilizando una tabla de caracteres equivocada. Este problema también suele ocurrir en las páginas web. Una página web  no es más que un fichero de texto con un formato determinado. Si el navegador no es capaz de inferir la codificación del fichero los  acentos pueden aparecer como caracteres extraños.&lt;/p&gt;

&lt;p&gt;En Linux hay varios programas que nos permiten cambiar los ficheros de una tabla de codificación a otra, uno de ellos es &lt;em&gt;iconv&lt;/em&gt;. Por ejemplo si tenemos un archivo con una codificación &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/sagan.utf-8.txt&#34; target=&#34;_blank&#34;&gt;UTF-8&lt;/a&gt; o &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/sagan.iso-8859-1.txt&#34; target=&#34;_blank&#34;&gt;ISO-8859-1&lt;/a&gt; podemos pasar de una a otra con &lt;em&gt;iconv&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ iconv -t ISO-8859-1 -f UTF-8 sagan.iso-8859-1 &amp;gt; sagan.utf-8_mod.txt
  ~$ iconv -f ISO-8859-1 -t UTF-8 sagan.utf-8.txt &amp;gt; sagan.iso-8859-1_mod.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fin-de-línea&#34;&gt;Fin de línea&lt;/h2&gt;

&lt;p&gt;Para marcar el final de una línea en un fichero de texto se utiliza  un carácter especial. Por desgracia no ha habido un acuerdo a la hora de decidirse cual es el  carácter que debe usarse. Unix, Windows y Mac OS utilizan caracteres diferentes. Afortunadamente los editores de texto suelen ser capaces de detectar las tres versiones y muestran el fichero con las líneas que esperamos. Desgraciadamente el notepad del Windows no es capaz de hacerlo por lo  que si abrimos un fichero de texto creado en Linux en el notepad nos  aparecerá como una larga línea con símbolos extraños intercalados. Casi todos los editores de texto permiten hacer el cambio entre los  distintos finales de línea.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ unix2dos -n sagan.utf-8.txt sagan.dos.tx
  ~$ cat -A sagan.uft-8.txt
  ~$ cat -A sagan.dos.txt
  ~$ dos2unix sagan.dos.tx
  ~$ cat -A sagan.dos.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;p&gt;Se ha realizado un estudio de un nuevo tratamiento para un linfoma y nos han enviado dos ficheros. En el llamando &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/cancer_progresion.txt&#34; target=&#34;_blank&#34;&gt;cancer_progresion.txt&lt;/a&gt; se encuentran tanto los datos de los pacientes como el resultado del tratamiento. En el &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/cancer_ciego.txt&#34; target=&#34;_blank&#34;&gt;segundo&lt;/a&gt; se encuentra la tabla que nos permitirá desentrañar el ensayo del doble ciego, con el identificador de cada paciente y la dosis de droga que se le administró.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Sobre el archivo microarray_adenoma_hk69, recupera sólo el primer resultado.&lt;/li&gt;
&lt;li&gt;¿Cuántos pacientes había en el estudio?&lt;/li&gt;
&lt;li&gt;¿De cuántos pacientes no tenemos datos de progresión?&lt;/li&gt;
&lt;li&gt;Convertir la separación de comas de la tabla de doble ciego a tabuladores (el tabulador se escribe como \t).&lt;/li&gt;
&lt;li&gt;Unir la tabla de los resultados de la terapia con la del doble ciego.&lt;/li&gt;
&lt;li&gt;Transformar el fichero resultante las comas a tabuladores.&lt;/li&gt;
&lt;li&gt;¿Cómo les ha ido a los pacientes según el tipo de tratamiento? (Placebo está escrito con mayúsculas y minúsculas)&lt;/li&gt;
&lt;li&gt;Crea un fichero con los primeros 100 resultados del microarray de adenoma que incluya sólo las primeras 10 columnas.&lt;/li&gt;
&lt;li&gt;Ordena el fichero micro.txt generado en la cuestión 7 por el  nombre del gen (campo 3) y por el id de la fila, pero en orden numérico  reverso.&lt;/li&gt;
&lt;li&gt;Disponemos de dos ficheros con secuencias de ADN: &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/seqs_1.fasta&#34; target=&#34;_blank&#34;&gt;seqs_1.fasta&lt;/a&gt; y &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/seqs_2.fasta&#34; target=&#34;_blank&#34;&gt;seqs_2.fasta&lt;/a&gt; ¿Cuántas secuencias hay en cada fichero? ¿Hay alguna secuencia presente en ambos ficheros? (En los archivos de secuencia tipo fasta el nombre  de las secuencias se encuentra en las líneas que comienzan por el  símbolo &lt;em&gt;&amp;gt;&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;Disponemos de un fichero con &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/seqs_3.fasta&#34; target=&#34;_blank&#34;&gt;secuencia de ADN&lt;/a&gt;, puedes extraer los nombres de las sequencias?&lt;/li&gt;
&lt;li&gt;Disponemos de un fichero con el resultado de un mapeo en &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/demo_data/tomate.sam&#34; target=&#34;_blank&#34;&gt;formato SAM&lt;/a&gt; ¿Cuntas secuencias se han mapeado? ¿Cuántas se han mapeado en dirección reversa (mirad la segunda columna: 0 forward; 16 reverse)? ¿Cuántos y  cuáles son los unigenes a los que se ha podido mapear alguna secuencia?  Ordena las nombres de secuencias mapeadas con el orden del unigene y la  posición en el unigene.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soluciones&#34;&gt;Soluciones&lt;/h2&gt;

&lt;p&gt;1.- Sobre el archivo microarray_adenoma_hk69, recupera sólo el primer resultado.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ tail -n +21 microarray_adenoma_hk69.csv | head -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.- ¿Cuántos pacientes había en el estudio?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -v nombre cancer_progresion.txt | wc -l
  11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.- ¿De cuántos pacientes no tenemos datos de progresión?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep  desconocido cancer_progresion.txt  | wc -l
  1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.- Convertir la separación de comas de la tabla de doble ciego  a tabuladores.   (El tabulador se escribe como \t)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sed -e &#39;s/,/\t/&#39; cancer_ciego.txt &amp;gt; cancer_ciego_tab.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.- Unir la tabla de los resultados de la terapia con la del doble ciego.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ join cancer_progresion.txt cancer_ciego_tab.txt &amp;gt; cancer.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;join&lt;/em&gt;, por defecto, crea la nueva tabla usando como separador los espacios. Para poder hacerlo correctamente con tabuladores habría que usar “join -t $’\t’”. Otro modo correcto y más sencillo de hacerlo sería pasar antes todos los tabuladores a comas y hacerlo con comas. Estas herramientas tienen este tipo de limitaciones, más adelante con Python podremos superarlas fácilmente.&lt;/p&gt;

&lt;p&gt;6.- Transformar el fichero resultante los espacios a tabuladores.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sed -e &#39;s/ /\t/g&#39; cancer.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.- ¿Cómo les ha ido a los pacientes según el tipo de tratamiento? (Placebo está escrito con mayúsculas y minúsculas)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -i placebo cancer.txt
  1 Pepe Granada buena placebo
  4 Mónica Madrid mala placebo
  7 Óscar Barcelona mala Placebo
  10 Jordi Barcelona mala Placebo
  ~$ grep -i 1mg cancer.txt
  2 Juan Lugo muy buena 1mg
  3 Alicia Valencia muy buena 1mg
  8 Trini Valencia muy buena 1mg
  ~$ grep -i 2mg cancer.txt
  5 Alberto Madrid regular 2mg
  6 Toni Toledo mala 2mg
  9 Pepe Valencia buena 2mg
  11 Manolo Sevilla desconocido 2mg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.- Crea un fichero con los primeros 100 resultados del microarray de adenoma que incluya sólo las primeras 10 columnas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -v &#39;^&amp;quot;&#39; microarray_adenoma_hk69.csv | head -n 100 | cut -f 1-10 &amp;gt; micro.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.- Ordena el fichero micro.txt generado en la cuestión 7 por el  nombre del gen (campo 3) y por el id de la fila, pero en orden numérico  reverso.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ sort -k 3 micro.txt
  ~$ sort -nr micro.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.- Disponemos de dos ficheros con secuencias de ADN (seqs_1.fasta y seqs_2.fasta). ¿Cuántas secuencias hay en cada fichero? ¿Hay alguna  secuencia presente en ambos ficheros? (En los archivos de secuencia tipo fasta el nombre de las secuencias se encuentra en las líneas que  comienzan por el símbolo &lt;em&gt;&amp;gt;&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Veamos cuantas secuencias hay en cada archivo y después contemos las  secuencias no repetidas que hay en un archivo que las incluya a todas.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ cat seqs_1.fasta | grep &#39;&amp;gt;&#39; | wc -l
  11
  ~$ cat seqs_2.fasta | grep &#39;&amp;gt;&#39; | wc -l
  11
  ~$ cat seqs_1.fasta seqs_2.fasta | grep &#39;&amp;gt;&#39; | sort | uniq | wc -l
  20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sí hay secuencias repetidas puesto que cuando las contamos todas juntas hay dos menos que cuando las contamos por separado. Podemos ver qué secuencias hay repetidas utilizando el parámetro &lt;em&gt;-d&lt;/em&gt; del uniq:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ cat seqs_1.fasta seqs_2.fasta | grep &#39;&amp;gt;&#39; | sort | uniq -d
  &amp;gt;gi|311207420|gb|GT728904.1|GT728904
  &amp;gt;gi|311210057|gb|GT715712.1|GT715712
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Efectivamente ambas secuencias se encuentran repetidas en los dos ficheros:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep &#39;&amp;gt;gi|311207420|gb|GT728904.1|GT728904&#39; seqs_1.fasta
  &amp;gt;gi|311207420|gb|GT728904.1|GT728904
  $ grep &#39;&amp;gt;gi|311207420|gb|GT728904.1|GT728904&#39; seqs_2.fasta
  &amp;gt;gi|311207420|gb|GT728904.1|GT728904
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.- Para poder extraer los nombres conviene primero echar un vistazo al fichero para ver que contiene.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep &amp;quot;&amp;gt;&amp;quot; seqs_3.fasta|cut -c 2- | cut -f 1 -d &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;12.-&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ~$ grep -v &amp;quot;^@&amp;quot; tomate.sam | wc
  ~$ grep -v &amp;quot;^@&amp;quot; tomate.sam | cut -f 2 | grep 16 | wc
  ~$ grep -v &amp;quot;^@&amp;quot; tomate.sam | cut -f 3 | sort -u
  ~$ grep -v &amp;quot;^@&amp;quot; tomate.sam | sort -k 3,4 |cut -f 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bibliografía&#34;&gt;Bibliografía&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Chris Herborth, &lt;a href=&#34;http://www.ibm.com/developerworks/aix/library/au-textprocess.html&#34; target=&#34;_blank&#34;&gt;Text processing with UNIX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;TDLP, &lt;a href=&#34;http://tldp.org/LDP/abs/html/textproc.html&#34; target=&#34;_blank&#34;&gt;Text Processing Commands&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Redes</title>
      <link>https://www.marcusrb.com/unix/12-redes/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/12-redes/</guid>
      <description>

&lt;h1 id=&#34;redes&#34;&gt;Redes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#ip&#34; target=&#34;_blank&#34;&gt;IP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#puerto&#34; target=&#34;_blank&#34;&gt;Puerto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#direccion-esttica-o-dinmicas&#34; target=&#34;_blank&#34;&gt;Direccion estática o dinámicas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#dns&#34; target=&#34;_blank&#34;&gt;DNS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#puerta-de-enlace&#34; target=&#34;_blank&#34;&gt;Puerta de enlace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dispositivos de red

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#ping&#34; target=&#34;_blank&#34;&gt;Ping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#ifconfig&#34; target=&#34;_blank&#34;&gt;ifconfig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#route&#34; target=&#34;_blank&#34;&gt;route&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#resolvconf&#34; target=&#34;_blank&#34;&gt;resolv.conf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/redes.html#servicios&#34; target=&#34;_blank&#34;&gt;Servicios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vamos a repasar algunos commandos genericos de Linux para poder conocer la configuracion actual del sistema.&lt;/p&gt;

&lt;h2 id=&#34;ip&#34;&gt;IP&lt;/h2&gt;

&lt;p&gt;Una dirección IP es un número que identifica un dispositivo  (computadora, tableta, portátil, smartphone) que utilice el protocolo IP (Internet Protocol).&lt;/p&gt;

&lt;h2 id=&#34;puerto&#34;&gt;Puerto&lt;/h2&gt;

&lt;p&gt;En el ámbito de Internet, un puerto es el valor que se usa, en el  modelo de la capa de transporte, para distinguir entre las múltiples  aplicaciones que se pueden conectar al mismo host, o puesto de trabajo. Aunque muchos de los puertos se asignan de manera arbitraria, ciertos  puertos se asignan, por convenio, a ciertas aplicaciones particulares o  servicios de carácter universal. Por ejemplo el puerto 80 para el  protocolo http(web).&lt;/p&gt;

&lt;h2 id=&#34;direccion-estática-o-dinámicas&#34;&gt;Direccion estática o dinámicas&lt;/h2&gt;

&lt;p&gt;Las ips se pueden configurar para que sea la que nosotros le digamos( direccion estática) o para que nos la de un servidior externo  (Direccion dinámica). Lo más comun es que la configuracion sea dinamica y que no tengamos que preocupernos sobre las diferentes  configuraciones.(DHCP)&lt;/p&gt;

&lt;h2 id=&#34;dns&#34;&gt;DNS&lt;/h2&gt;

&lt;p&gt;Cuando queremos acceder a una página web, en el ordenador no solemos  escribir la IP del ordenador donde está alojada la página. Solemos  escribir el nombre del dominio. El servicio encargado de traducir los  dominios en ips es el DNS.(Domain Name Server)&lt;/p&gt;

&lt;p&gt;Cuando tecleamos en el navegador google.es, lo primero que hace el  navegador es preguntarle al servidor dns cual es la IP a la que está  asociado ese dominio, cuando se la devuelve, el navegador llega al  servidor usando la IP, no el dominio.&lt;/p&gt;

&lt;p&gt;Para nosotros sería muy dificil recordar las ips de las diferentes  páginas webs, más aun, cuando estas están continuamente cambiando. Para  guardar la relación dominio ip, es para lo que existen los DNS.&lt;/p&gt;

&lt;h2 id=&#34;puerta-de-enlace&#34;&gt;Puerta de enlace&lt;/h2&gt;

&lt;p&gt;La pasarela (en inglés gateway) o puerta de enlace, es el dispositivo que actúa de interfaz de conexión entre aparatos o dispositivos, y  también posibilita compartir recursos entre dos o más computadoras.&lt;/p&gt;

&lt;h2 id=&#34;dispositivos-de-red&#34;&gt;Dispositivos de red&lt;/h2&gt;

&lt;p&gt;Son aquellos elementos fisicos que permiten al ordenador communicarse con otro ordenador. Existen dispositivos que permiten conectarse de  forma inalambrica y mediante cable.&lt;/p&gt;

&lt;p&gt;En linux a cada uno de los dispositivos se les da un identificador, y es este identificador por el cual podremos configurarlos.&lt;/p&gt;

&lt;p&gt;Cada dispositivo de red tiene una MAC. Es un identificador unico  entre todos los dispositivos de red que existen en el mundo. En las  redes de computadoras, la dirección MAC (siglas en inglés de media  access control; en español “control de acceso al medio”) es un  identificador de 48 bits (6 bloques hexadecimales) que corresponde de  forma única a una tarjeta o dispositivo de red. Se conoce también como  dirección física.&lt;/p&gt;

&lt;h3 id=&#34;ping&#34;&gt;Ping&lt;/h3&gt;

&lt;p&gt;Ping es una utilidad diagnostica que nos permite conocer el estado de la comunicacion entre un ordenador y otro.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ping google.es
PING google.es (216.58.201.131) 56(84) bytes of data.
64 bytes from mad06s25-in-f3.1e100.net (216.58.201.131): icmp_seq=1 ttl=63 time=7.80 ms
64 bytes from mad06s25-in-f3.1e100.net (216.58.201.131): icmp_seq=2 ttl=63 time=7.61 ms
64 bytes from mad06s25-in-f3.1e100.net (216.58.201.131): icmp_seq=3 ttl=63 time=7.55 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es muy util porque en caso de problemas de conectividad nos ayudara a diagnosticar la fuente del problema.&lt;/p&gt;

&lt;h3 id=&#34;ifconfig&#34;&gt;ifconfig&lt;/h3&gt;

&lt;p&gt;Es un programa disponible en varias versiones del sistema operativo  UNIX, que permite configurar o desplegar numerosos parámetros de las  interfaces de red, como la dirección IP o la máscara de red. Si se llama sin argumentos suele mostrar la configuración vigente de las interfaces de red activas, con detalles como la dirección MAC o el tráfico que ha  circulado por las mismas hasta el momento. Las interfaces de red en  Linux se suelen denominar eth (eth0, eth1, etc.).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ifconfig
enp0s3    Link encap:Ethernet  direcciónHW 08:00:27:33:99:e7  
          Direc. inet:10.0.2.15  Difus.:10.0.2.255  Másc:255.255.255.0
          Dirección inet6: fe80::9c0a:cb8b:c9d8:f705/64 Alcance:Enlace
          ACTIVO DIFUSIÓN FUNCIONANDO MULTICAST  MTU:1500  Métrica:1
          Paquetes RX:593738 errores:0 perdidos:0 overruns:0 frame:0
          Paquetes TX:107227 errores:0 perdidos:0 overruns:0 carrier:0
          colisiones:0 long.colaTX:1000
         Bytes RX:795191090 (795.1 MB)  TX bytes:9027221 (9.0 MB)

lo        Link encap:Bucle local  
          Direc. inet:127.0.0.1  Másc:255.0.0.0
          Dirección inet6: ::1/128 Alcance:Anfitrión
          ACTIVO BUCLE FUNCIONANDO  MTU:65536  Métrica:1
          Paquetes RX:3511 errores:0 perdidos:0 overruns:0 frame:0
          Paquetes TX:3511 errores:0 perdidos:0 overruns:0 carrier:0
          colisiones:0 long.colaTX:1
          Bytes RX:592400 (592.4 KB)  TX bytes:592400 (592.4 KB)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;route&#34;&gt;route&lt;/h3&gt;

&lt;p&gt;Con el comando route, podremos saber cual es el gateway o puerta de acceso de las interfaces del ordenador.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ route -n
Tabla de rutas IP del núcleo
Destino         Pasarela        Genmask         Indic Métric Ref    Uso Interfaz
0.0.0.0         10.0.2.2        0.0.0.0         UG    100    0        0 enp0s3
10.0.2.0        0.0.0.0         255.255.255.0   U     100    0        0 enp0s3
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 enp0s3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resolv-conf&#34;&gt;resolv.conf&lt;/h3&gt;

&lt;p&gt;Si queremos saber cuales son las DNS que estamos utilizando, lo podemos mirar en el fichero resolf.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cat /etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 127.0.1.1
search upv.es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si queremos resolver un dominio a ip, podemos usar el comando &lt;code&gt;host&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ host bioinf.comav.upv.es
bioinf.comav.upv.es is an alias for proxybioinf.comav.upv.es.
proxybioinf.comav.upv.es has address 158.42.125.13
proxybioinf.comav.upv.es mail is handled by 20 mxv.cc.upv.es.
proxybioinf.comav.upv.es mail is handled by 30 mx2.cc.upv.es.
proxybioinf.comav.upv.es mail is handled by 10 mx4.cc.upv.es.
proxybioinf.comav.upv.es mail is handled by 50 vega.cc.upv.es.
proxybioinf.comav.upv.es mail is handled by 10 albali.cc.upv.es.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;servicios&#34;&gt;Servicios&lt;/h1&gt;

&lt;p&gt;Los servicios son una serie de procesos que se ejecutan al arrancar el ordenador y que se quedan ejecutando en &lt;em&gt;background&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Tenemos servicios que se encargan desde la configuracion de red como  servicios para mostrarnos las paginas web. En ubuntu y debian podemos  ver todos los servicios que estan ejecutandose con el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ systemctl list-units
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos tambien ver el estado de un servicio concreto, iniciarlo,  pararlo o que vuelva a leer la configuracion con el commando systemctl.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ systemctl status cron
● cron.service - Regular background program processing daemon
   Loaded: loaded (/lib/systemd/system/cron.service; enabled; vendor preset: ena
   Active: active (running) since mar 2016-09-27 15:25:29 CEST; 23h ago
     Docs: man:cron(8)
 Main PID: 609 (cron)
   CGroup: /system.slice/cron.service
           └─609 /usr/sbin/cron -f

sep 28 11:17:04 virtual CRON[2136]: pam_unix(cron:session): session opened for u
sep 28 11:17:04 virtual CRON[2143]: (root) CMD (   cd / &amp;amp;&amp;amp; run-parts --report /e
sep 28 12:17:01 virtual CRON[2535]: pam_unix(cron:session): session opened for u
sep 28 12:17:01 virtual CRON[2536]: (root) CMD (   cd / &amp;amp;&amp;amp; run-parts --report /e
sep 28 13:17:01 virtual CRON[2814]: pam_unix(cron:session): session opened for u
sep 28 13:17:01 virtual CRON[2815]: (root) CMD (   cd / &amp;amp;&amp;amp; run-parts --report /e
sep 28 13:17:01 virtual CRON[2814]: pam_unix(cron:session): session closed for u
sep 28 14:17:01 virtual CRON[3333]: pam_unix(cron:session): session opened for u
sep 28 14:17:01 virtual CRON[3334]: (root) CMD (   cd / &amp;amp;&amp;amp; run-parts --report /e
sep 28 14:17:01 virtual CRON[3333]: pam_unix(cron:session): session closed for u
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scripts de bash</title>
      <link>https://www.marcusrb.com/unix/07-scripts-bash/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/07-scripts-bash/</guid>
      <description>

&lt;h1 id=&#34;scripts-de-bash&#34;&gt;Scripts de bash&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Variables

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#nombre-de-las-variables&#34; target=&#34;_blank&#34;&gt;Nombre de las variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Control de flujo

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#bucles-for&#34; target=&#34;_blank&#34;&gt;Bucles (&lt;em&gt;for&lt;/em&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Condicionales (&lt;em&gt;if&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#condicionales-con-nmeros&#34; target=&#34;_blank&#34;&gt;Condicionales con números&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#condicionales-con-cadenas-de-texto&#34; target=&#34;_blank&#34;&gt;Condicionales con cadenas de texto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#condicionales-con-archivos&#34; target=&#34;_blank&#34;&gt;Condicionales con archivos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Manipulación de cadenas de texto

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#extraer-subcadena&#34; target=&#34;_blank&#34;&gt;Extraer subcadena&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#borrar-subcadena&#34; target=&#34;_blank&#34;&gt;Borrar subcadena&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#reemplazar-subcadena&#34; target=&#34;_blank&#34;&gt;Reemplazar subcadena&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#operaciones-aritmticas&#34; target=&#34;_blank&#34;&gt;Operaciones aritméticas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#parallel&#34; target=&#34;_blank&#34;&gt;Parallel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/scripts_bash.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En esta sección del curso vamos a aprender a hacer algunos scripts  básicos que nos permitan automatizar y acelerar el trabajo. Un script no es más que un archivo que contiene un conjunto de órdenes para realizar una acción.&lt;/p&gt;

&lt;p&gt;Vamos a crear nuestro primer script. Para ello en un editor de texto  escribiremos lo siguente y lo guardaremos con el nombre *hola.sh *&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	# Este es nuestro primer progrma
	echo Hola Mundo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación iremos a la terminal y lo ejecutaremos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ~$ ./hola.sh.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La primera línea de nuestro script le indica al sistema que tiene que usar la shell BASH. La segunda línea es un comentario para consumo  humano, todas las líneas que comiencen por &lt;code&gt;#&lt;/code&gt; son ignoradas por la máquina y nos sirven para incluir comentarios  destinados a programadores o usuarios. En la tercera línea tenemos el  comando &lt;code&gt;echo&lt;/code&gt;que sirve para imprimir texto en la pantalla.&lt;/p&gt;

&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;

&lt;p&gt;Como cualquier otro lenguaje de programación, necesitamos variables  que nos servirán para guardar datos en la memoria del ordenador hasta el momento que los necesitemos. Podemos pensar en una variable como una  caja en la que podemos guardar un elemento (e.g, un número, una cadena  de texto, la dirección de un archivo…) y, siguiendo con el símil, la  memoria del ordenador no sería más que el conjunto de esas cajas.&lt;/p&gt;

&lt;p&gt;Para asignar el valor a una variable simplemente simplemente debemos usar el signo &lt;code&gt;=&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nombre_variable=valor_variable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es importante no dejar espacios ni antes ni después del &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para recuperar el valor de dicha variable sólo hay que anteponer el símbolo de dolar &lt;code&gt;$&lt;/code&gt; antes del nombre de la variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$nombre_variable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lo largo de un script podemos asignarle diferentes valores a una misma variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	to_print=&#39;Hola mundo&#39;
	echo $to_print
	to_print=5.5
	echo $to_print
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nombre-de-las-variables&#34;&gt;Nombre de las variables&lt;/h3&gt;

&lt;p&gt;Las variables pueden tomar prácticamente cualquier nombre, sin embargo, existen algunas restricciones:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sólo puede contener caracteres alfanuméricos y guiones bajos&lt;/li&gt;
&lt;li&gt;El primer carácter debe ser una letra del alfabeto o “_” (este último caso se suele reservar para casos especiales).&lt;/li&gt;
&lt;li&gt;No pueden contener espacios.&lt;/li&gt;
&lt;li&gt;Las mayúsculas y las minúsculas importan, “a” es distinto de “A”.&lt;/li&gt;
&lt;li&gt;Algunos nombres som usado como variables de entorno y no los debemos utilizar para evitar sobrescribirlas (e.g.,PATH).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De manera general, y para evitar problemas con las variables de  entorno que siempre están escritas en mayúscula, deberemos escribir el  nombre de las variables en minúscula.&lt;/p&gt;

&lt;p&gt;Además, aunque esto no es una regla que deba obedecerse  obligatoriamente, es conveniente que demos a las variables nombres que  más tarde podamos recordar. Si abrimos un script tres meses después de haberlo escrito y nos  encontramos con la expresión “m=3.5” nos será difícil entender que hace  el programa. Habría sido mucho más claro nombrar la variable como “media=3.5”.&lt;/p&gt;

&lt;h2 id=&#34;control-de-flujo&#34;&gt;Control de flujo&lt;/h2&gt;

&lt;p&gt;Como hemos visto los scripts se ejecutan línea a línea hasta llegar  al final, sin embargo, muchas veces nos interesará modificar ese  comportamiento de manera que el programa pueda responder de un modo u  otro dependiendo de las cirscunstancias o pueda repetir trozos de  código.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/for_if.png&#34; alt=&#34;flow control&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En este curso nos vamos a centrar en los controles de flujo más importantes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;bucles (&lt;em&gt;for loops&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;condicionales (&lt;em&gt;if&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bucles-for&#34;&gt;Bucles (&lt;em&gt;for&lt;/em&gt;)&lt;/h3&gt;

&lt;p&gt;La sintaxis general de los bucles es la siguiente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for VARIABLE in LISTA_VALORES;
do
	COMANDO 1
	COMANDO 2
	...
	COMANDO N
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Donde la lista de valores puede ser un rango númerico:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for VARIABLE in 1 2 3 4 5 6 7 8 9 10;
	for VARIABLE in {1..10};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;una serie de valores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for VARIABLE in file1 file2 file3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;o el resutlado de la ejecución de un comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for VARIABLE in $(ls /bin | grep -E &#39;c.[aeiou]&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hay que tener en cuenta que si pasamos un listado de valores pero lo  ponemos entrecomillado, el ordenador lo enterá como un única línea:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	for VARIABLE in &amp;quot;file1 file2 file3&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un ejemplo simple de &lt;em&gt;for&lt;/em&gt; sería:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	for numero in {1..20..2};
	do
	  echo Este es el número: $numero
	done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;condicionales-if&#34;&gt;Condicionales (&lt;em&gt;if&lt;/em&gt;)&lt;/h3&gt;

&lt;p&gt;La sintaxis básica de un condicional es la siguiente&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if [[ CONDICIÓN ]];
	then
	  COMANDO 1 si se cumple la condición
	fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También se puede especificar qué hacer si la condición no se cumple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if [[ CONDICIÓN ]];
	then
	  COMANDO 1 si se cumple la condición
	else
	  COMANDO 2 si no se cumple la condición
	fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Incluso se pueden añadir más condiciones concatenando más &lt;em&gt;if&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if [[ CONDICIÓN 1 ]];
	then
	  COMANDO 1 si se cumple la condición 1
	elif [[ CONDICIÓN 2 ]];
	then
	  COMANDO 2 si se cumple la condición 2
	else
	  COMANDO 3 si no se cumple la condición 2
	fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;condicionales-con-números&#34;&gt;Condicionales con números&lt;/h4&gt;

&lt;p&gt;Al comparar números podemos realizar las siguientes operaciones:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;operador&lt;/th&gt;
&lt;th&gt;significado&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-lt&lt;/td&gt;
&lt;td&gt;menor que (&amp;lt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-gt&lt;/td&gt;
&lt;td&gt;mayor que (&amp;gt;)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-le&lt;/td&gt;
&lt;td&gt;menor o igual que (&amp;lt;=)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-ge&lt;/td&gt;
&lt;td&gt;mayor o igual que (&amp;gt;=)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-eq&lt;/td&gt;
&lt;td&gt;igual (==)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-ne&lt;/td&gt;
&lt;td&gt;no igual (!=)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	num1=$1  # la variable toma el primer valor que le pasamos al script
	num2=$2  # la variable toma el segundo valor que le pasamos al script
	if [[ $num1 -gt $num2 ]];
	then
	  echo $num1 es mayor que $num2
	else
	  echo $num2 es mayor que $num1
	fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;condicionales-con-cadenas-de-texto&#34;&gt;Condicionales con cadenas de texto&lt;/h4&gt;

&lt;p&gt;A la hora de comparar cadenas de texto:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;operador&lt;/th&gt;
&lt;th&gt;significado&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;=&lt;/td&gt;
&lt;td&gt;igual, las dos cadenas de texto son exactamente idénticas&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;!=&lt;/td&gt;
&lt;td&gt;no igual, las cadenas de texto no son exactamente idénticas&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;es menor que (en orden alfabético ASCII)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;es mayor que (en orden alfabético ASCII)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-n&lt;/td&gt;
&lt;td&gt;la cadena no está vacía&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-z&lt;/td&gt;
&lt;td&gt;la cadena está vacía&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	string1=&#39;reo&#39;
	string2=&#39;teo&#39;
	if [[ $string1 &amp;gt; $string2 ]];
	then
	  echo Eso es verdad
	else
	  echo Eso es mentira
	fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos hacer comparaciones haciendo uso de &lt;em&gt;wildcards&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	string1=&#39;reo&#39;
	if [[ $string1 = *e* ]];
	then
	  echo Eso es verdad
	else
	  echo Eso es mentira
	fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;condicionales-con-archivos&#34;&gt;Condicionales con archivos&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;operador&lt;/th&gt;
&lt;th&gt;Devuelve &lt;em&gt;true&lt;/em&gt; si&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-e name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; existe&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; es un archivo normal (no es un directorio)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-s name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; NO tiene tamaño cero&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; es un directorio&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; tiene permiso de lectura para el user que corre el script&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-w name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; tiene permiso de escritura para el user que corre el script&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-x name&lt;/td&gt;
&lt;td&gt;&lt;em&gt;name&lt;/em&gt; tiene permiso de ejecución para el user que corre el script&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Por ejemplo, podemos hacer un script que nos informe sobre el contenido de un directorio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/bin/bash
	for file in $(ls);
	do
	  if [[ -d $file ]];
	  then
	    echo directorio: $file
	  else
	    if [[ -x $file ]];
	    then
	      echo archivo ejecutable: $file
	    else
	      echo archivo no ejecutable: $file
	    fi
	  fi
	done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;manipulación-de-cadenas-de-texto&#34;&gt;Manipulación de cadenas de texto&lt;/h2&gt;

&lt;h3 id=&#34;extraer-subcadena&#34;&gt;Extraer subcadena&lt;/h3&gt;

&lt;p&gt;Mediante &lt;code&gt;${cadena:posicion:longitud}&lt;/code&gt; podemos extraer una subcadena de otra cadena. Si omitimos :longitud,  entonces extraerá todos los caracteres hasta el final de cadena.&lt;/p&gt;

&lt;p&gt;Por ejemplo en la cadena &lt;code&gt;string=abcABC123ABCabc&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo ${string:0}&lt;/code&gt; : abcABC123ABCabc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string:0:1}&lt;/code&gt; : a (primer caracter)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string:7} :&lt;/code&gt;  23ABCabc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string:7:3}&lt;/code&gt; : 23A (3 caracteres desde posición 7)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string:7:-3}&lt;/code&gt; : 23ABCabc (desde posición 7 hasta el final)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string: -4}&lt;/code&gt; : Cabc (atención al espacio antes del menos)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string: -4:2}&lt;/code&gt; : Ca (atención al espacio antes del menos)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;borrar-subcadena&#34;&gt;Borrar subcadena&lt;/h3&gt;

&lt;p&gt;Hay diferentes formas de borrar subcadenas de una cadena:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${cadena#subcadena}&lt;/code&gt; : borra la coincidencia más corta de subcadena desde el principio de cadena&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${cadena##subcadena}&lt;/code&gt; : borra la coincidencia más larga de subcadena desde el principio de cadena&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por ejemplo, en la cadena &lt;code&gt;string=abcABC123ABCabc&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo ${string#a*C}&lt;/code&gt; : 123ABCabc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string##a*C}&lt;/code&gt; : abc&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;reemplazar-subcadena&#34;&gt;Reemplazar subcadena&lt;/h3&gt;

&lt;p&gt;También existen diferentes formas de reemplazar subcadenas de una cadena:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${cadena/buscar/reemplazar}&lt;/code&gt; : Sustituye la primera coincidencia de &lt;em&gt;buscar&lt;/em&gt; con &lt;em&gt;reemplazar&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${cadena//buscar/reemplazar}&lt;/code&gt; : Sustituye todas las coincidencias de &lt;em&gt;buscar&lt;/em&gt; con &lt;em&gt;reemplazar&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por ejemplo, en la cadena &lt;code&gt;string=abcABC123ABCabc&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo ${string/abc/xyz}&lt;/code&gt; : xyzABC123ABCabc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo ${string//abc/xyz}&lt;/code&gt; : xyzABC123ABCxyz.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;operaciones-aritméticas&#34;&gt;Operaciones aritméticas&lt;/h2&gt;

&lt;p&gt;Por último, Bash también permite la operaciones aritméticas con número enteros:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;+ - : suma, resta&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ $num=10
~$ echo $((num + 2))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;** : potencia&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $((num ** 2))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;* / % : multiplicación, división, resto (módulo)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $((num * 2))
~$ echo $((num / 2))
~$ echo $((num % 2))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;VAR++ VAR– : post-incrementa, post-decrementa&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $((num++))
~$ echo $num
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;++VAR –VAR : pre-incrementa, pre-decrementa&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $((++num))
~$ echo $num
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;parallel&#34;&gt;Parallel&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;parallel&lt;/em&gt; es un programa que permite la ejecución en paralelo de diferentes trabajos siempre que dispongamos de un ordenador o   ordenadores con más de un procesador.&lt;/p&gt;

&lt;p&gt;Aunque este programa no tiene nada que ver con los scripts de Bash,   sí que hacer uso de éstos no resultará muy útil para preparar el archivo de entrada para &lt;em&gt;parallel&lt;/em&gt;.  Este programa requiere pasarle un  archivo donde cada línea es trabajo a realizar y puede consistir tanto  en un comando como en un pequeño script a ejecutar. Y es ahí donde saber algo de scripting en Bash nos puede facilitar la tarea. Veamos un  ejemplo de &lt;em&gt;input&lt;/em&gt; para &lt;em&gt;parallel&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	to_run.txt:
	zcat file1.fasta.gz | grep &#39;&amp;gt;&#39; | sed &#39;s/&amp;gt;//&#39; | bgzip &amp;gt; sample_names1.txt.gz
	zcat file2.fasta.gz | grep &#39;&amp;gt;&#39; | sed &#39;s/&amp;gt;//&#39; | bgzip &amp;gt; sample_names2.txt.gz
	zcat file3.fasta.gz | grep &#39;&amp;gt;&#39; | sed &#39;s/&amp;gt;//&#39; | bgzip &amp;gt; sample_names3.txt.gz
	zcat file4.fasta.gz | grep &#39;&amp;gt;&#39; | sed &#39;s/&amp;gt;//&#39; | bgzip &amp;gt; sample_names4.txt.gz
	zcat file5.fasta.gz | grep &#39;&amp;gt;&#39; | sed &#39;s/&amp;gt;//&#39; | bgzip &amp;gt; sample_names5.txt.gz
	zcat file6.fasta.gz | grep &#39;&amp;gt;&#39; | sed &#39;s/&amp;gt;//&#39; | bgzip &amp;gt; sample_names6.txt.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;parallel&lt;/em&gt; no viene instalado por defecto en algunas distribuciones Linux, por tanto, lo primero que debemos hacer es instalarlo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	~$ sudo apt-get install parallel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con la opción &lt;em&gt;-j&lt;/em&gt; podemos especificarle el número de trabajos simultáneos. Así pues, si tenemos 4 procesadores disponibles y queremos correr un trabajo por procesador correríamos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	~$ parallel -j 4 to_run.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Haz un script que cree 40 archivos &lt;em&gt;.txt&lt;/em&gt; en una carpeta de tu escritorio (usa &lt;em&gt;touch&lt;/em&gt; para crearlos)&lt;/li&gt;
&lt;li&gt;Haz un script que comprima con &lt;em&gt;gzip&lt;/em&gt; sólo los archivos 25 y 29.&lt;/li&gt;
&lt;li&gt;Escribe un script que cambie la extensión de los ficheros que contengan un 3 en su nombre de &lt;em&gt;.txt&lt;/em&gt; a &lt;em&gt;.md&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Crea un script que copie todos los archivos (no directorios) &lt;em&gt;/etc&lt;/em&gt; a una carpeta de tu escritorio.&lt;/li&gt;
&lt;li&gt;Prepara un script que cuenta el número de directorios y archivos que hay en &lt;em&gt;/etc&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Haz un script que devuelva el número de archivos que has guardado&lt;/li&gt;
&lt;li&gt;Supon que tenemos un programa en Python llamado &lt;em&gt;scan_qtl.py&lt;/em&gt; que requiere tres parámetros de entrada &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;. Queremos correr todas la combinaciones paramétricas posibles para &lt;em&gt;a&lt;/em&gt; de 1 a 10 de 1 en 1 y &lt;em&gt;b&lt;/em&gt; = [pop1, pop2, pop3, all]. Prepa el archivo de entrada para usar en &lt;em&gt;parallel&lt;/em&gt;. La línea de ejecución del programa sería algo similar a &lt;code&gt;python scan_qtl.py 1 pop1 &amp;gt; results.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;En una nueva versión de &lt;em&gt;scan_qtl.py&lt;/em&gt;, el programa admite un tercer parámetro &lt;em&gt;c&lt;/em&gt; = [1, 10, 100 y 1000]. Prepara el archivo de entrada para usar en &lt;em&gt;parallel&lt;/em&gt; con todas las combinaciones paramétricas de &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt; y &lt;em&gt;c&lt;/em&gt;. La línea de ejecución del programa sería algo similar a &lt;code&gt;python scan_qtl.py 1 pop1 100 &amp;gt; results.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Sistema de ficheros</title>
      <link>https://www.marcusrb.com/unix/02-sistema-ficheros/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/02-sistema-ficheros/</guid>
      <description>

&lt;p&gt;El &lt;a href=&#34;https://en.wikipedia.org/wiki/File_system&#34; target=&#34;_blank&#34;&gt;sistema de archivos&lt;/a&gt; controla como se almacenan los archivos en el ordenador. Sus dos tareas principales son guardar y leer archivos previamente guardados.&lt;/p&gt;

&lt;h2 id=&#34;sistemas-jerárquicos&#34;&gt;Sistemas jerárquicos&lt;/h2&gt;

&lt;p&gt;Los sistemas de archivos suelen tener &lt;a href=&#34;https://en.wikipedia.org/wiki/Directory_(computing)&#34; target=&#34;_blank&#34;&gt;directorios&lt;/a&gt; en los que organizar los archivos y estos directorios suelen estar organizados jerárquicamente. La jerarquía implica que un directorio puede contener subdirectorios. El directorio más alto en la jerarquía del que cuelgan todos los demás se denomina &lt;em&gt;raíz&lt;/em&gt; (root). En los sistemas Unix el directorio raíz se representa con una barra “*/*” y sólo existe una jerarquía, es decir, sólo existe un directorio raíz, incluso aunque haya distintos discos duros en el ordenador.&lt;/p&gt;

&lt;p&gt;Dentro del directorio raíz podemos encontrar diversos subdirectorios, por ejemplo en Linux existe el directorio &lt;em&gt;home&lt;/em&gt;. &lt;em&gt;home&lt;/em&gt; es por tanto un subdictorio del directorio raíz. Esta relación se representa como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;home&lt;/em&gt; es el directorio dónde se encuentran los directorios de los usuarios en un sistema Linux. Imaginemos que tiene los subdirectorios &lt;em&gt;alicia&lt;/em&gt; y &lt;em&gt;juan&lt;/em&gt;. Se representaría como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia
/home/juan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existe un estándar, denominado &lt;a href=&#34;https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard&#34; target=&#34;_blank&#34;&gt;Filesystem Hierarchy Standard&lt;/a&gt; que define la estructura de directorios de los sistemas Unix. Los sistemas Unix suelen seguir este estándar, aunque a veces lo violan en algunos aspectos. Por ejemplo en MacOS X el directorio donde se encuentran los direcotorios de los usuarios se denomina &lt;em&gt;Users&lt;/em&gt; y no &lt;em&gt;home&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;En algunos sistemas operativos no UNIX la barra se escribe al revés “&amp;rdquo;, a pesar de que la convención siempre fue la contraria.&lt;/p&gt;

&lt;p&gt;En el directorio raíz hay diversos directorios que, en la mayoría de los casos, sólo deberían interesarnos si estamos administrando el ordenador. Los usuarios normalmente sólo escriben dentro de un directorio de su propiedad localizado dentro de /home y denominado como su nombre de usuario.&lt;/p&gt;

&lt;p&gt;Los usuarios también pueden escribir en /tmp aunque normalmente son los procesos lanzados por estos lo que hacen esta escritura. Es importante revisar el espacio libre en la partición en la que se encuentra /tmp para que no se colapse el sistema. Recuerda que /tmp es borrado habitualmente por el sistema. Normalmente con cada nuevo arranque.&lt;/p&gt;

&lt;h2 id=&#34;rutas-absolutas-relativas-y-directorio-de-trabajo&#34;&gt;Rutas absolutas, relativas y directorio de trabajo&lt;/h2&gt;

&lt;p&gt;Para referirnos a un archivo o a un directorio debemos indicar su ruta (&lt;a href=&#34;https://en.wikipedia.org/wiki/Path_(computing)&#34; target=&#34;_blank&#34;&gt;path&lt;/a&gt;. Un ejemplo de ruta podría ser:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia/documentos/tesis.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este tipo de rutas en las que se especifican todos los subdirectorios empezando desde el directorio raíz se denominan rutas absolutas.&lt;/p&gt;

&lt;p&gt;Para no tener que escribir la ruta absoluta completa cada vez que queremos referirnos a un archivo o a un directorio se crearon los conceptos de &lt;a href=&#34;https://en.wikipedia.org/wiki/Working_directory&#34; target=&#34;_blank&#34;&gt;directorio de trabajo&lt;/a&gt; y de &lt;a href=&#34;https://en.wikipedia.org/wiki/Path_(computing)#Absolute_and_relative_paths&#34; target=&#34;_blank&#34;&gt;ruta relativa&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El directorio de trabajo es una propiedad del terminal (del shell) en la que estamos trabajando. Siempre que estemos trabajando en una terminal tendremos asignado un directorio de trabajo. Por ejemplo, si nuestro usuario es &lt;em&gt;alicia&lt;/em&gt; sería normal que al abrir un terminal nuestro directorio de trabajo fuese:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El directorio de trabajo se utiliza para escribir rutas a archivos relativas al mismo. De este modo nos ahorramos escribir bastante. Imaginemos que Alicia tiene en su directorio un documento llamado peliculas.txt. La ruta absoluta sería.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia/peliculas.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mientras su directorio de trabajo sea /home/alicia la ruta relativa sería simplemetne:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peliculas.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es decir, podemos escribir rutas relativas al directorio de trabajo, rutas que en vez de partir del directorio raíz parten desde el directorio de trabajo. Las rutas relativas se diferencian de las absolutas en los sistemas Unix porque las absolutas empiezan por “y” las relativas no.&lt;/p&gt;

&lt;p&gt;Es común referirse al directorio de trabajo de una terminal como a un lugar en el que nos encontramos mientras estamos trabajando en la terminal. Siempre que estemos en una terminal estaremos dentro de un directorio de trabajo.&lt;/p&gt;

&lt;p&gt;Por ejemplo, cuando abrimos un nuevo terminal el directorio de trabajo se sitúa en /home/nombre_de_usuario. Si ejecutamos el comando &lt;em&gt;ls&lt;/em&gt;, el programa asumirá que queremos listar los archivos presentes en ese directorio y no en otro cualquiera. Existe un comando que nos informa sobre el directorio de trabajo actual, pwd (Print Working Directory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pwd
/home/alicia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si deseamos podemos modificar el directorio de trabajo “moviéndonos” a otro directorio. Para lograrlo hay que utilizar el comando &lt;em&gt;cd&lt;/em&gt; (Change Directory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd documentos
$ pwd
/home/alicia/documentos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A partir de ese momento los comandos asumirán que si no se les indica lo contrario el directorio desde el que deben trabajar es /home/alicia/documentos.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;cd&lt;/em&gt; además tiene algunos parámetros especiales:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd      Ir al directorio $HOME del usuario.
cd -    Ir al directorio de trabajo previo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;directorio-home&#34;&gt;Directorio $HOME&lt;/h2&gt;

&lt;p&gt;El directorio $HOME en los sistemas Unix, que son sistemas multiusuario, es el directorio en el que el usuario debe mantener sus ficheros y directorios. Fuera de este directorio el usuario tendrá unos permisos restringidos puesto que sus acciones podrían afectar a otros usuarios.&lt;/p&gt;

&lt;p&gt;En Linux los directorios $HOME de los usuarios son subdirectorios del directorio &lt;em&gt;/home&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El directorio $HOME de un usuario es además el directorio de trabajo por defecto, es decir, el directorio de trabajo que se establece cuando se abre una terminal.&lt;/p&gt;

&lt;h2 id=&#34;moviendo-renombrando-y-copiando-ficheros&#34;&gt;Moviendo, renombrando y copiando ficheros&lt;/h2&gt;

&lt;p&gt;En primer lugar vamos a crear un fichero de prueba:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ touch data.txt
~$ ls
data.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El comando &lt;em&gt;touch&lt;/em&gt;, en este caso, ha creado un fichero vacío.&lt;/p&gt;

&lt;p&gt;Los ficheros se copian con el comando &lt;em&gt;cp&lt;/em&gt; (CoPy):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp data.txt data.bak.txt
~$ ls
data.bak.txt  data.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se mueven y renombran con el &lt;em&gt;mv&lt;/em&gt; (MoVe):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mv data.txt experimento_1.txt
~$ ls
data.bak.txt  experimento_1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para crear un nuevo directorio podemos utilizar la orden &lt;em&gt;mkdir&lt;/em&gt; (MaKeDIRectory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mkdir exp_1
~$ ls
data.bak.txt  exp_1  experimento_1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;mv&lt;/em&gt; también sirve para mover ficheros entre directorios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mv experimento_1.txt exp_1/
~$ ls
data.bak.txt  exp_1
~$ ls exp_1/
experimento_1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Los ficheros se eliminan con la orden &lt;em&gt;rm&lt;/em&gt; (ReMove):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ rm data.bak.txt
~$ ls
exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En la línea de comandos de los sistemas Unix cuando se borra un fichero se borra definitivamente, no hay papelera. Una vez ejecutado el &lt;em&gt;rm&lt;/em&gt; no podremos recuperar el archivo.&lt;/p&gt;

&lt;p&gt;Los comandos &lt;em&gt;cp&lt;/em&gt; y &lt;em&gt;rm&lt;/em&gt; no funcionarán bien con los directorios a no ser que modifiquemos el comportamiento que muestran por defecto:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ rm exp_1/
rm: cannot remove exp_1/ Is a directory
~$ cp exp_1/ exp_1_bak/
cp: omitting directory exp_1/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esto sucede porque para copiar o borrar un directorio hay que copiar o borrar todos sus contenidos recursivamente y esto podría alterar muchos datos con un sólo comando. Por esta razón se exige que estos dos comandos incluyan un modificador que les indique que sí deben funcionar recursivamente cuando tratan con directorios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp -r exp_1/ exp_1_bak/
~$ ls
exp_1  exp_1_bak
~$ rm -r exp_1_bak/
~$ ls
exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nombres-de-directorios-y-archivos&#34;&gt;Nombres de directorios y archivos&lt;/h2&gt;

&lt;p&gt;En Unix los archivos pueden tener prácticamente cualquier nombre. Existe la convención de acabar los nombres con un punto y una pequeña extensión que indica el tipo de archivo. Pero esto es sólo una convención, en realidad podríamos no utilizar este tipo de nomenclatura.&lt;/p&gt;

&lt;p&gt;Si deseamos utilizar nombres de archivos que no vayan a causar extraños comportamientos en el futuro lo mejor sería seguir unas cuantas reglas al nombrar un archivo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Añadir una extensión para recordarnos el tipo de archivo, por ejemplo .txt para los archivos de texto.&lt;/li&gt;
&lt;li&gt;No utilizar en los nombres:

&lt;ul&gt;
&lt;li&gt;espacios,&lt;/li&gt;
&lt;li&gt;caracteres no alfanuméricos,&lt;/li&gt;
&lt;li&gt;ni caracteres no ingleses como letras acentuadas o eñes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por supuesto, podríamos crear un archivo denominado “$ñ 1.txt” para referirnos a un archivo de sonido, pero esto conllevaría una sería de problemas que aunque son solventables nos dificultarán el trabajo.&lt;/p&gt;

&lt;p&gt;Además es importante recordar que en Unix las mayúsculas y las minúsculas no son lo mismo. Los ficheros “documento.txt”, “Documento.txt” y “DOCUMENTO.TXT” son tres ficheros distintos.&lt;/p&gt;

&lt;p&gt;Otra convención utilizada en los sistema Unix es la de ocultar los archivos cuyos nombres comienzan por punto “.”. Por ejemplo el archivo “.oculto” no aparecerá normalmente cuando pedimos el listado de un directorio. Esto se utiliza normalmente para guardar archivos de configuración que no suelen ser utilizados directamente por los usuarios. Para listar todos los archivos (All), ya sean éstos ocultos o no se puede ejecutar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -a
.               .fontconfig          .HyperTree           .pki
..               fsm.jpg              .ICEauthority        .recently-used
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta convención de ocultar los ficheros cuyo nombre comienza por un punto se mantiene también en el navegador gráfico de ficheros. En este caso podemos pedir que se muestren estos archivos en el menú Ver -&amp;gt; Mostrar los archivos ocultos.&lt;/p&gt;

&lt;p&gt;Para acelerar el acceso a ciertos directorios existen algunos nombres especiales que son bastante útiles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* &amp;quot;..&amp;quot; indica el directorio padre del directorio actual
* &amp;quot;.&amp;quot; indica el directorio actual
* &amp;quot;~&amp;quot; representa la $HOME del usuario
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wildcards&#34;&gt;WildCards&lt;/h2&gt;

&lt;p&gt;En muchas ocasiones resulta útil tratar los ficheros de un modo conjunto. Por ejemplo, imaginemos que queremos mover todos los ficheros de texto a un directorio y la imágenes a otro. Creemos una pequeña demostración::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ touch exp_1a.txt
~$ touch exp_1b.txt
~$ touch exp_1b.jpg
~$ touch exp_1a.jpg
~$ ls
exp_1  exp_1a.jpg  exp_1a.txt  exp_1b.jpg  exp_1b.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos referirnos a todos los archivos que acaban en txt utilizando un asterisco:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mv *txt exp_1
~$ ls
exp_1  exp_1a.jpg  exp_1b.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El asterisco sustituye a cualquier texto, por lo que al escribir *txt incluimos a cualquier fichero que tenga un nombre cualquiera, pero que termine con las letras txt. Podríamos por ejemplo referirnos a los ficheros del experimento 1a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls *1a*
exp_1a.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta herramienta es muy potente y útil, pero tenemos que tener cuidado con ella, sobre todo cuando la combinamos con &lt;em&gt;rm&lt;/em&gt;. Por ejemplo la orden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -r *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Borraría todos los ficheros y directorios que se encuentren bajo el directorio de trabajo actual, si lo hacemos perderemos todos los ficheros y directorios que cuelgan del actual directorio de trabajo, puede que esto sea lo que queramos, pero hemos de andar con cuidado.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;¿Cuáles son los ficheros y directorios presentes en el directorio raíz?&lt;/li&gt;
&lt;li&gt;¿Cuáles son todos los archivos presentes en nuestro directorio de usuario?&lt;/li&gt;
&lt;li&gt;Crea un directorio llamado experimento.&lt;/li&gt;
&lt;li&gt;Crea con touch los archivos datos1.txt y datos2.txt dentro del directorio experimento.&lt;/li&gt;
&lt;li&gt;Vuelve al directorio principal de tu usuario y desde allí lista los archivos presentes en el directorio experimento usando rutas absolutas y relativas&lt;/li&gt;
&lt;li&gt;Haz del directorio ~/Documentos tu directorio de trabajo y repite el ejercicio anterior&lt;/li&gt;
&lt;li&gt;Borra todos los archivos que contengan un 2 en el directorio experimento.&lt;/li&gt;
&lt;li&gt;Copia el directorio experimento a un nuevo directorio llamado exp_seguridad.&lt;/li&gt;
&lt;li&gt;Borra el directorio experimento.&lt;/li&gt;
&lt;li&gt;Renombra el directorio exp_seguridad a experimento.&lt;/li&gt;
&lt;li&gt;Copia el fichero /etc/passwd al directorio ~/Documentos&lt;/li&gt;
&lt;li&gt;Copia el fichero /etc/passwd al directorio ~/Documentos llamándolo usuarios.txt&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;obteniendo-información-sobre-archivos-y-directorios&#34;&gt;Obteniendo información sobre archivos y directorios&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;ls&lt;/em&gt; es un comando capaz de mostrarnos información extra sobre los archivos y directorios que lista. Por ejemplo podemos pedirle, usando la opción &lt;em&gt;-l&lt;/em&gt; (Long), que nos muestre quién es el dueño del archivo y cuanto ocupa y qué permisos tiene además de otras cosas::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls
exp_1
~$ ls -l
total 4
drwxr-xr-x 2 usuario usuario 4096 Oct 13 09:48 exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La información sobre la cantidad de disco ocupada la da por defecto en bytes, si la queremos en un formato más inteligible podemos utilizar la opción &lt;em&gt;-h&lt;/em&gt; (Human):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls -lh
total 4.0K
drwxr-xr-x 2 usuario usuario 4.0K Oct 13 09:48 exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos consultar el tipo de un archivo mediante el comando &lt;em&gt;file&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ file imagen.png
imagen.png: PNG image data, 1920 x 1080, 8-bit/color RGB, non-interlaced
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En principio, el tipo de un archivo no está determinado por la extensión, la extensión es sólo parte del nombre, aunque hay software que viola o complementa este principio. El tipo de archivo está determinado por su &lt;a href=&#34;https://en.wikipedia.org/wiki/Magic_number_(programming)&#34; target=&#34;_blank&#34;&gt;magic number&lt;/a&gt;. El magic number está compuesto por una corta &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_file_signatures&#34; target=&#34;_blank&#34;&gt;serie de bytes&lt;/a&gt; que indican el tipo de archivo.&lt;/p&gt;

&lt;h2 id=&#34;permisos&#34;&gt;Permisos&lt;/h2&gt;

&lt;p&gt;Unix desde su origen ha sido un sistema multiusuario. Para conseguir que cada usuario pueda trabajar en sus archivos, pero que no pueda interferir accidental o deliberadamente con los archivos de otros usuarios se estableció desde el principio un sistema de permisos. Por defecto un usuario tiene permiso para leer y modificar sus propios archivos y directorios, pero no los de los demás. En los sistemas Unix los ficheros pertenecen a un usuario concreto y existen unos permisos diferenciados para este usuario y para el resto. Además el usuario pertenece a un grupo de trabajo. Por ejemplo, imaginemos que la usuaria alicia puede pertenecer al grupo de trabajo “diagnostico”. Si alicia crea un fichero este tendrá unos permisos diferentes para alicia, para el resto de miembros de su grupo y para el resto de usuarios del ordenador. Podemos ver los permisos asociados a los ficheros utilizando el comando &lt;em&gt;ls&lt;/em&gt; con la opción -l (Long)::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls -l
total 7324
-rw-r--r-- 1 alicia diagnostico    1059 Oct 20 12:42 busqueda_leukemia_100.txt
-rw-r--r-- 1 alicia diagnostico       0 Oct 13 10:53 datos_1.txt
drwxr-xr-x 2 alicia diagnostico    4096 Oct 13 10:29 experimento
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso, los ficheros listados pertenecen Alicia y al grupo diagnostico. Los permisos asignados al usuario, a los miembros del grupo y al resto de usuarios están resumidos en la primeras letras de cada línea::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-x---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La primera letra indica el tipo de fichero listado: (d) directorio, (-) fichero u otro tipo especial. Las siguientes nueve letras muestran, en grupos de tres, los permisos para el usuario, para el grupo y para el resto de usuarios del ordenador. Cada grupo de tres letras indica los permisos de lectura (Read), escritura (Write) y ejecución (eXecute). En el caso anterior el usuario tiene permiso de lectura, escritura y ejecución (rwx), el grupo tiene permiso de lectura y ejecución (r-x), es decir no puede modificar el fichero o el directorio, y el resto de usuarios no tienen ningún permiso (—).&lt;/p&gt;

&lt;p&gt;En los ficheros normales el permiso de lectura indica si el fichero puede ser leído, el de escritura si puede ser modificado y el de ejecución si puede ser ejecutado. En el caso de los directorios el de escritura indica si podemos añadir o borrar ficheros del directorio y el de ejecución si podemos listar los contenidos del directorio.&lt;/p&gt;

&lt;p&gt;Estos permisos pueden ser modificados con la orden &lt;em&gt;chmod&lt;/em&gt;. En chmod cada grupo de usuarios se representa por una letra:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u: usuario dueño del fichero&lt;/li&gt;
&lt;li&gt;g: grupo de usuarios del dueño del fichero&lt;/li&gt;
&lt;li&gt;o: todos los otros usuarios&lt;/li&gt;
&lt;li&gt;a: todos los tipos de usuario (dueño, grupo y otros)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los tipos de permisos también están abreviados por letras:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;r: lectura&lt;/li&gt;
&lt;li&gt;w: escritura&lt;/li&gt;
&lt;li&gt;x: ejecución&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con estas abreviaturas podemos modificar los permisos existentes.&lt;/p&gt;

&lt;p&gt;Hacer un fichero ejecutable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod u+x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a+x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos mediante chmod indicar los permisos para un tipo de usuario determinado.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a=rwx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un modo algo menos intuitivo, pero más útil de utilizar chmod es mediante los números octales que representan los permisos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- lectura: 4
- escritura: 2
- ejecución: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para modificar los permisos de este modo debemos indicar el número octal que queremos que represente los permisos del fichero. La primera cifra representará al dueño, la segunda al grupo y la tercera al resto de usuarios. Por ejemplo si queremos que único permiso para el dueño y su grupo sea la lectura y que no haya ningún permiso para el resto de usuarios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 110 fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos combinar permisos sumando los números anteriores. Por ejemplo, permiso para leer y escribir para el dueño y ningún permiso para el resto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 300 fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Permisos de lectura, escritura y ejecución para el dueño y su grupo y ninguno para el resto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 770 fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las restricciones para los permisos no afectan al usuario root, al administrador del sistema. root también puede modificar quien el dueño y el grupo al que pertenecen los ficheros mediante los comando chown y chgrp.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chown alicia fichero.txt
$ chown diagnostico fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obteniendo-información-sobre-el-sistema-de-archivos&#34;&gt;Obteniendo información sobre el sistema de archivos&lt;/h2&gt;

&lt;p&gt;El sistema de archivos puede abarcar una o más &lt;a href=&#34;https://en.wikipedia.org/wiki/Disk_partitioning&#34; target=&#34;_blank&#34;&gt;particiones&lt;/a&gt;. Una partición es una región de un disco o de cualquier otro medio de almacenamiento. Las instalaciones de Windows tienen normalmente una partición por disco, pero en Linux esto no es tan habitual. Cada partición tiene un sistema de archivos propio, pero en Unix estos sistemas deben estar montados en algún lugar dentro de la jerarquía que cuelga de la raíz. En Windows cada partición tiene por defecto una jerarquía independiente.&lt;/p&gt;

&lt;p&gt;Podemos pedir información sobre el espacio ocupado por las distintas particiones que tenemos actualmente montadas usando el comando &lt;em&gt;df&lt;/em&gt; (Disk Free).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -h
S.ficheros     Tamaño Usados  Disp Uso% Montado en
udev             7,8G      0  7,8G   0% /dev
tmpfs            1,6G   9,8M  1,6G   1% /run
/dev/nvme0n1p2    25G   8,1G   16G  35% /
tmpfs            7,8G   5,3M  7,8G   1% /dev/shm
tmpfs            5,0M   4,0K  5,0M   1% /run/lock
tmpfs            7,8G      0  7,8G   0% /sys/fs/cgroup
/dev/nvme0n1p4   206G    18G  178G   9% /home
/dev/nvme0n1p1   511M   3,6M  508M   1% /boot/efi
/dev/sda1        2,7T   117G  2,5T   5% /home/jose/magnet
tmpfs            1,6G    64K  1,6G   1% /run/user/1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Algunos de los sistemas de archivos montados puede que no se correspondan con particiones en un disco físico sino con espacios de la memoria RAM que son utilizados como sistemas de archivos especiales.&lt;/p&gt;

&lt;p&gt;El commando &lt;em&gt;du&lt;/em&gt; (disk usage) informa sobre el espacio que ocupa un árbol de directorios. Este comando tiene equivalentes gráficos como Baobab o xdiskusage. Podemos pedir a &lt;em&gt;du&lt;/em&gt; que nos muestre cuanto espacio ocupan los directorios bajo el directorio analysis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -h analyses/
36K	analyses/alicia/cache
204K	analyses/alicia/differential_snps/differential
252K	analyses/alicia/differential_snps/non_differentia
919M	analyses/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si sólo queremos obtener el resultado para el directorio que le hemos dado y no para sus subdirectorios podemos utilizar el parámetro &lt;em&gt;-s&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -sh analyses/
919M	analyses/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si queremos información sobre todos los archivos y no sólo los directorios podemos usar &lt;em&gt;-a&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -ha analyses/
32K	analyses/alicia/cache/min_called_rate_samples_cache.pickle
36K	analyses/alicia/cache
8,0K	analyses/alicia/look_for_matching_accessions.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ejercicios-1&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;¿Cuáles son los permisos de los directorios presentes en el directorio raíz y en nuestro directorio de usuario? ¿A quién pertenecen los ficheros y qué permisos tienen los distintos usuarios del ordenador?&lt;/li&gt;
&lt;li&gt;Crea un directorio en tu home y muestra los permisos que tiene.&lt;/li&gt;
&lt;li&gt;Cambia los permisos para que sólo tu usuario pueda acceder al nuevo directorio&lt;/li&gt;
&lt;li&gt;Crea un fichero nuevo y dale permisos de ejecución para todos los usuarios&lt;/li&gt;
&lt;li&gt;Último fichero modificado en el directorio /etc.&lt;/li&gt;
&lt;li&gt;Lista los ficheros de /etc con su tamaño y ordénalos por tamaño.&lt;/li&gt;
&lt;li&gt;Copia todos los ficheros y directorios del directorio /etc cuyo nombre comience por s. ¿Has podido copiarlos todos?&lt;/li&gt;
&lt;li&gt;¿Cuánto espacio libre queda en las distintas particiones del sistema?&lt;/li&gt;
&lt;li&gt;¿Cuánto espacio ocupan todos los ficheros y subdirectorios de tu $HOME?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;compresion-y-descompresión-de-ficheros&#34;&gt;Compresion y descompresión de ficheros&lt;/h2&gt;

&lt;p&gt;Existen distintos formatos de compresión de ficheros como: gzip, bzip, zip o rar. Los formatos más utilizados en Unix son gzip y bzip.&lt;/p&gt;

&lt;p&gt;Comprimir un fichero con gzip o bzip:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gzip informacion_snps.txt
$ ls
informacion_snps.txt.gz

$ bzip2 accs.txt
$ ls
accs.txt.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bzip2 comprime más que gzip, pero es más lento. gzip también dispone de varios niveles de compresión, cuanto más comprime más lenta suele ser la compresión.&lt;/p&gt;

&lt;p&gt;Podemos descomprimir cualquier fichero utilizando la línea de comandos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gunzip informacion_snps.txt.gz
$ ls
informacion_snps.txt
$ bunzip2 accs.txt.bz2
$ ls
accs.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muchos estamos acostumbrados al formato zip. Un fichero zip no se corresponde en realidad con un sólo fichero comprimido sino con varios. Un fichero zip hace dos cosas: unir varios ficheros en uno y comprimir el resultado. Los comandos que hemos visto (gzip y bzip2) son capaces de comprimir un sólo archivo, pero no pueden unir varios archivos en uno. &lt;em&gt;tar&lt;/em&gt; es el comando capaz de unir varios archivos en uno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
seq1.fasta  seq2.fasta
$ tar -cvf secuencias.tar seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;tar&lt;/em&gt; también es capaz de desempaquetar los archivos que habíamos unido.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
secuencias.tar
$ rm seq1.fasta seq2.fasta
$ tar -xvf secuencias.tar
seq1.fasta
seq2.fasta
$ ls
secuencias.tar  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El problema es que utilizando el comando &lt;em&gt;tar&lt;/em&gt; tal y como lo hemos hecho hemos conseguido unir y separar archivos, pero no hemos comprimido el fichero unido. Para hacerlo podríamos utilizar los comandos &lt;em&gt;gzip&lt;/em&gt; o &lt;em&gt;bzip2&lt;/em&gt;, pero este no es el modo habitula de hacerlo. Dado que casi siempre que unamos archivos en un archivo tar también querremos comprimir el resultado el comando tar tiene también la capacidad de comprimir y descomprimir utilizando los algoritmos gzip y bzip2. Unir y comprimir con gzip varios archivos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -cvzf secuencias.tar.gz seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.gz  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Descomprimir un archivo tar.gz:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -xvzf secuencias.tar.gz
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.gz  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos descomprimir el contenido de un fichero de texto y enviar el resultado a la terminal con el comando &lt;em&gt;zcat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;$ zcat fichero.txt.gz&lt;/p&gt;

&lt;p&gt;Con bzip2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -cvjf secuencias.tar.bz seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.bz  seq1.fasta  seq2.fasta

$ tar -xvjf secuencias.tar.bz
seq1.fasta
seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ejercicios-2&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Crea un fichero de texto en el directorio ~/Documentos y comprimelo con gzip&lt;/li&gt;
&lt;li&gt;Muestra el contenido del fichero anterior en pantalla sin descomprimirlo previamente&lt;/li&gt;
&lt;li&gt;Crea un archivo tar de todo el contenido del directorio ~/Documentos&lt;/li&gt;
&lt;li&gt;Comprime el fichero tar anterior&lt;/li&gt;
&lt;li&gt;Vuelve a hacer los ejercicios 2 y 3, pero en un sólo paso&lt;/li&gt;
&lt;li&gt;Descomprime el fichero tar.gz anterior en un nuevo directorio llamado Documentos2&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;enlaces-duros-y-blandos&#34;&gt;Enlaces duros y blandos&lt;/h2&gt;

&lt;p&gt;Podemos pensar en el nombre de un fichero como en una etiqueta que apunta a una posición concreta en el disco duro, en realidad es un puntero a un &lt;a href=&#34;https://en.wikipedia.org/wiki/Inode&#34; target=&#34;_blank&#34;&gt;inodo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Podmeos pensar en un &lt;a href=&#34;https://en.wikipedia.org/wiki/Hard_link&#34; target=&#34;_blank&#34;&gt;enlace duro&lt;/a&gt; como en un nombre adicional para un archivo. Si tenemos un archivo en el disco y creamos un enlace duro tendremos dos nombres para ese único archivo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
archivo1.txt
$ ln archivo1.txt nombre2.txt
$ ls
archivo1.txt nombre2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las dos referencias, nombres, al archivo serán indistinguibles. Si borramos un nombre quedará el otro. Si modificamos un archivo se modifica independientemente del nombre por el cual estemos accediendo a él. No es muy común utilizar enlaces duro salvo en aplicaciones muy concretas, por ejemplo en versiones de copias de seguridad.&lt;/p&gt;

&lt;p&gt;Un enlace blando, más comumente conocido como un enlace simbólico, es una referencia al nombre de un archivo, no al archivo en sí.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
archivo1.txt
$ ln -s archivo1.txt nombre3.txt
$ ls -l
-rw-rw-r-- 1 jose jose  0 sep 27 15:16 archivo1.txt
lrwxrwxrwx 1 jose jose 12 sep 27 15:16 nombre3.txt -&amp;gt; archivo1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si eliminamos el archivo original el enlace quedará roto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm archivo1.txt
$ cat nombre3.txt
cat: nombre3.txt: No existe el archivo o el directorio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El comportamiento de ambos tipos de enlaces cambia si sobreescribimos el fichero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x
$ echo &amp;quot;hola&amp;quot; &amp;gt; hola.txt
$ cat hola.txt
hola
$ ln hola.txt hola2.txt
$ ln -s hola.txt hola3.txt
$ ls -l
-rw-rw-r-- 2 jose jose 5 sep 27 15:23 hola2.txt
lrwxrwxrwx 1 jose jose 8 sep 27 15:25 hola3.txt -&amp;gt; hola.txt
-rw-rw-r-- 2 jose jose 5 sep 27 15:23 hola.txt
$ echo &amp;quot;adios&amp;quot; &amp;gt; adios.txt
$ mv adios.txt hola.txt
$ cat hola.txt
adios
$ cat hola2.txt
hola
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Los enlaces blandos funcionan incluso entre distintos sistemas de archivos o particiones, los duros no.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios-3&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Crea un enlace simbólico a un fichero de texto dentro del direcotorio ~/Documentos&lt;/li&gt;
&lt;li&gt;Crea un enlace duro al mismo fichero.&lt;/li&gt;
&lt;li&gt;Edita el fichero de texto y observa como cambian ambos enlaces&lt;/li&gt;
&lt;li&gt;Crea un nuevo fichero de texto con otro contenido. Sustituye el primer fichero con el segundo y observa el resultado en ambos enlaces&lt;/li&gt;
&lt;li&gt;Crea dos enlaces, uno simbólico y otro duro, a un fichero. Elimina el fichero y observa el resultado en ambos enlaces&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;acceso-remoto&#34;&gt;Acceso remoto&lt;/h2&gt;

&lt;p&gt;Una de las grandes ventajas de utilizar la terminal es que podemos acceder a terminales en otros ordenadores muy fácilmente. El protocolo más utilizado para acceder a terminales de forma remota es &lt;a href=&#34;https://en.wikipedia.org/wiki/Secure_Shell&#34; target=&#34;_blank&#34;&gt;ssh&lt;/a&gt; (Secure Shell). ssh tiene un gran número de posibilidades, pero el uso más habitual es utilizarlo para abrir terminales en ordenadores remotos que tienen un servicio ssh. ssh es seguro porque cifra las comunicaciones entre el cliente y el servidor. ssh se diseñó como una alternativa segura a telnet. No debemos usar el protocolo telnet porque las comunicaciones en telnet, incluidas las claves de acceso, no están cifradas y cualquiera puede tener acceso a ellas.&lt;/p&gt;

&lt;p&gt;Para acceder a una computadora que implemente el protocolo ssh podemos usar el programa ssh, pero previamente tenemos que tener una cuenta en esa computadora. Imaginemos que alicia tiene una cuenta en un ordenador que tiene un servicio ssh. Para conectarse puede hacer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh alicia@ordenador.upv.es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si el nombre de la cuenta de usuario en el ordenador cliente y en el servidor es el mismo puede obviar el nombre de usuario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ordenador.upv.es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación el servidor le pedirá la clave correspondiente a ese usuario.&lt;/p&gt;

&lt;p&gt;Existen clientes ssh para windows con los que nos podemos conectar a servidores ssh. Uno muy común es &lt;a href=&#34;http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html&#34; target=&#34;_blank&#34;&gt;putty&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una tarea muy habitual cuando estamos trabajando en un ordenador remoto es enviar o traer ficheros desde el mismo. Esto también lo podemos hacer utilizando el protocolo ssh por lo que podremos hacerlo de un modo seguro en cualquier ordenador que no de acceso ssh. El programa más sencillo para hacerlo desde Unix es &lt;a href=&#34;https://en.wikipedia.org/wiki/Secure_copy&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;scp&lt;/em&gt;&lt;/a&gt; (Secure CoPy). &lt;em&gt;scp&lt;/em&gt; tiene una interfaz muy similar a &lt;em&gt;cp&lt;/em&gt; pero acepta que los ficheros de origen y destino estén en distintos ordenadores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scp alicia@remotehost.edu:/remote/directory/seq.txt /some/local/directory
$ scp /some/local/directory/seq.txt alicia@remotehost.edu:/remote/directory/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En windows también hay distintos clientes scp, uno de ellos es &lt;a href=&#34;https://winscp.net/eng/download.php&#34; target=&#34;_blank&#34;&gt;winscp&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una alternativa a scp que tiene más capacidades, como enviar fragmentos de ficheros, es &lt;a href=&#34;https://en.wikipedia.org/wiki/Rsync&#34; target=&#34;_blank&#34;&gt;rsync&lt;/a&gt;. &lt;em&gt;rsync&lt;/em&gt; está diseñado para mantener varios archivos sincronizados entre dos ordenadores, pero también ser puede utilizar para copiar archivos de un ordenador a otro como scp. &lt;em&gt;rsync&lt;/em&gt; puede establecer la conexión utilizando distintos protocolos, pero uno de ellos es ssh por lo que funcionará también con cualquier servidor ssh.&lt;/p&gt;

&lt;p&gt;Si lo que queremos es descargar un fichero desde un servidor en internet, por ejemplo desde una página web, al ordenador remoto en el que estamos trabajando en una sesión ssh podemos utilizar el comando &lt;em&gt;wget&lt;/em&gt; o su alternativa &lt;em&gt;curl&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget https://http://ncbi.nlm.nih.gov/una_secuencia.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ejercicios-4&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Contectate a un servidor remoto usando ssh&lt;/li&gt;
&lt;li&gt;Transfiere un fichero desde tu ordenador al servidor&lt;/li&gt;
&lt;li&gt;Descarga el fichero &lt;a href=&#34;https://www.gnu.org/licenses/gpl.txt&#34; target=&#34;_blank&#34;&gt;https://www.gnu.org/licenses/gpl.txt&lt;/a&gt; directamente en el ordenador remoto&lt;/li&gt;
&lt;li&gt;Copia el fichero gpl.txt a tu ordenador&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Variables de entorno</title>
      <link>https://www.marcusrb.com/unix/10-variables-entorno/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/10-variables-entorno/</guid>
      <description>

&lt;h1 id=&#34;variables-de-entorno&#34;&gt;Variables de entorno&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/variables_de_entorno.html#donde-estn-los-ejecutables-path&#34; target=&#34;_blank&#34;&gt;¿Donde están los ejecutables? $PATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/variables_de_entorno.html#home&#34; target=&#34;_blank&#34;&gt;HOME&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/variables_de_entorno.html#ejercicios&#34; target=&#34;_blank&#34;&gt;Ejercicios&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Las variables de entorno son una lista de ajustes que guardan varios  estados de una sesión. Cuando se inicia una sesión ya sea en el entrono  gráfico o en una terminal, se leen las variables de entorno. Para poder acceder al contenido de una variable podemos utilizar el  commando &lt;code&gt;echo&lt;/code&gt; y el nombre de la variable precedido de un $:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $LANG
  es_ES.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este comando nos muestra el idioma en el que se mostraran los mensajes en la &lt;em&gt;shell&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Si queremos ver las variables de entorno que estamos usando, tenemos el comando &lt;code&gt;env&lt;/code&gt;. Nos mostrará todas las variables de entorno que hay cargadas en nuestra sesión.&lt;/p&gt;

&lt;p&gt;Podemos configurar las variables de entorno modificando los archivos  de configuración de la shell. En nuestro caso la shell por defecto que  usamos es bash, por lo tanto el fichero de configuración que debemos  usar es: &lt;code&gt;$HOME/.bashrc&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ nano $HOME/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una de las variables de entorno que se puede configurar es la variable PATH.&lt;/p&gt;

&lt;h3 id=&#34;donde-están-los-ejecutables-path&#34;&gt;¿Donde están los ejecutables? $PATH&lt;/h3&gt;

&lt;p&gt;Cuando entramos en la &lt;em&gt;shell&lt;/em&gt; y ejecutamos un programa la &lt;em&gt;shell&lt;/em&gt; ha de saber dónde encontrar el ejecutable correspondiente a ese comando. Este ejecutable es un fichero con el mismo nombre que hemos escrito en la &lt;em&gt;shell&lt;/em&gt; y que tiene el permiso de ejecución activado. Por ejemplo el ejecutable del comando &lt;em&gt;cp&lt;/em&gt; es:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls -l /bin/cp
-rwxr-xr-x 1 root root 109648 2010-09-21 20:32 /bin/cp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso el fichero /bin/cp es un ejecutable que pertenece al  usuario root, pero que todo el mundo puede leer y ejecutar y que se  encuentra en el directorio /bin. Dado que el comando &lt;em&gt;cp&lt;/em&gt; es simplemente un fichero ejecutable en bin para utilizarlo deberíamos escribir su ruta completa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ /bin/cp fichero1.txt fichero2.bak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aunque podríamos ejecutar el comando de ese modo nunca lo hemos hecho. De alguna forma la &lt;em&gt;shell&lt;/em&gt; ha sabido encontrar el comando &lt;em&gt;cp&lt;/em&gt; en el directorio /bin a pesar de que no se lo hemos dicho.&lt;/p&gt;

&lt;p&gt;Cuando intentamos ejecutar un comando lo que la &lt;em&gt;shell&lt;/em&gt; hace  es buscar el fichero ejecutable correspondiente en una lista de  directorios que se encuentra almacenada en una variable de entorno  denominada &lt;code&gt;PATH&lt;/code&gt;. Podemos imprimir esta lista utilizado el comando &lt;em&gt;echo&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En el ejemplo mostrado al escribir un comando en la &lt;em&gt;shell&lt;/em&gt;,  ésta lo buscará primero en el directorio /usr/local/sbin, después en  /usr/local/bin y así sucesivamente hasta que lo encuentre en alguno de  los directorios del $PATH. Si el comando no se encuentra la &lt;em&gt;shell&lt;/em&gt; devolverá un error::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ hola
  No se ha encontrado la orden «hola», quizás quiso decir:
  La orden «cola» del paquete «git-cola» (universe)
  hola: orden no encontrada
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cuando intentemos ejecutar programas creados por nosotros mismos o  descargados desde algún lugar deberemos tener este detalle en cuenta. Por ejemplo, si descargamos un ejecutable llamado hola_mundo y después  intentamos ejecutarlo, la &lt;em&gt;shell&lt;/em&gt; no lo encontrará:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls
 hola_mundo
~$ hola_mundo
 No se ha encontrado la orden «hola», quizás quiso decir:
 La orden «cola» del paquete «git-cola» (universe)
 hola_mundo: orden no encontrada
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La &lt;em&gt;shell&lt;/em&gt; no lo encuentra porque el directorio de trabajo (“.”) no está incluido en el PATH. Podríamos ejecutar el comando si le indicamos a la &lt;em&gt;shell&lt;/em&gt; la ruta en la que se encuentra el comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ /home/usuario/hola_mundo
 Hola mundo!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podríamos utilizar una ruta relativa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ./hola_mundo
 Hola mundo!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O podemos añadir el directorio donde se encuentra el ejecutable en el PATH. Si por ejemplo instalamos un programa en nuestra home en el directorio  programa, podemos añadir este directorio al path y ejecutar el programa  simplemente ejecutandolo con su nombre.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;programa: /home/user/dibujacirculos/bin/draw_circle
añadimos al path:/home/user/dibujacirculos/bin
nuevo PATH: PATH=/home/user/dibujacirculos/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para que la shell &lt;em&gt;cargue&lt;/em&gt; la variable de entorno, podemos utilizar el comando &lt;code&gt;source&lt;/code&gt; que actualizará las variables de entorno con los valores que hayamos puesto en el fichero que carguemos, en este caso &lt;code&gt;.bashrc&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ source $HOME/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se puede dar el caso que tengamos el mismo programa instalado por dos metodos distintos.  Ambos programs tienen un ejecutable que se llama  igual. Como podemos saber cual de los ejecutables se está ejecutando? En linux tenemos el comando &lt;code&gt;which&lt;/code&gt;  que nos revolvera la ruta completa. La shell va recorriendo los  directorios del path en orden hasta que en alguno encuentra el  ejecutable. &lt;code&gt;which&lt;/code&gt; devuelve el path completo del ejecutable que la &lt;em&gt;shell&lt;/em&gt; usa.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ which cp
 /bin/cp
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;home&#34;&gt;HOME&lt;/h3&gt;

&lt;p&gt;Otra variable de entorno que se usa mucho es la variable HOME. Hace  referencia a la carpeta personal de usuario. Para el usuario &lt;code&gt;user&lt;/code&gt; la carpeta es: /home/user&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ echo $HOME
/home/user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos cambiar el valor de una variable de entorno. Los cambios que  hagamos solo se veran en la terminal en la que estemos. Si queremos que  la variable la “hereden” las aplicaciones que lanzamos desde esa shell  tenemos que hacer la variable disponible, para ello podemo user el  comando &lt;code&gt;export&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=/binarios:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por ello en el fichero &lt;code&gt;.bashrc&lt;/code&gt; las variables las tenemos que definir con export delante.&lt;/p&gt;

&lt;h3 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Crea un directorio bin en tu directorio de trabajo. Usa Una  variable de entorno en el comando. Despues añade el directorio al path,  para todas las sessiones.&lt;/li&gt;
&lt;li&gt;Crea una variable de entorno nueva que muestre tu nombre. Por  ejemplo NOMBRE. Haz que se pueda utilizar solo en la terminal en la que  lo has creado.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
