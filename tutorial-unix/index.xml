<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Unix, Shell y Bash | MarcusRB | consultor &amp; profesor data analytics • AI • Big Data</title>
    <link>https://www.marcusrb.com/tutorial-unix/</link>
      <atom:link href="https://www.marcusrb.com/tutorial-unix/index.xml" rel="self" type="application/rss+xml" />
    <description>Tutorial de Unix, Shell y Bash</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><copyright>© 2021</copyright><lastBuildDate>Wed, 24 Jun 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://www.marcusrb.com/img/icon-192.png</url>
      <title>Tutorial de Unix, Shell y Bash</title>
      <link>https://www.marcusrb.com/tutorial-unix/</link>
    </image>
    
    <item>
      <title>UNIX from Scratch</title>
      <link>https://www.marcusrb.com/unix/01-unix-intro/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/01-unix-intro/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Unix&#34; target=&#34;_blank&#34;&gt;Unix&lt;/a&gt; es una familia de sistemas operativos. La primera versión de Linux fue desarrollada a partir de 1969. Unix se caracteriza por ser portable y multitarea.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Unix#/media/File:Unix_history-simple.svg&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/unix_history.png&#34; alt=&#34;Unix history&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hoy en día los sistemas operativos Unix son ampliamente utilizados en multitud de dispositivos que abarcan desde los supercomputadores más capaces hasta los teléfonos móviles más populares, pasando por los ordenadores que utilizamos diariamente en nuestros escritorios. La filosofía de los sistemas Unix se caracteriza por:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un sistema de ficheros jerárquico,&lt;/li&gt;
&lt;li&gt;una gran colección de pequeños programas que pueden trabajar en serie,&lt;/li&gt;
&lt;li&gt;el uso de ficheros de texto para almacenar los datos,&lt;/li&gt;
&lt;li&gt;tratar los dispositivos como ficheros.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt; y MacOS X son ejemplos de sistemas Unix.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/Unix&#34; target=&#34;_blank&#34;&gt;Unix&lt;/a&gt; es un sistema operativo portable, multitarea y multiusuario desarrollado a partir de 1969.&lt;/p&gt;

&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/Linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt; es una familia de sistemas operativos de tipo Unix que utilizan el kernel Linux. Linux puede instalarse en prácticamente cualquier ordenador personal además en en teléfonos móviles y supercomputadores.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/tux.png&#34; alt=&#34;Tux&#34; /&gt;&lt;/p&gt;

&lt;p&gt;El nombre proviene del programador original, un estudiante llamado Linus Torvals, que en 1991 completando las herramientas GNU desarrolladas por el proyecto GNU de la &lt;a href=&#34;http://www.fsf.org/&#34; target=&#34;_blank&#34;&gt;Fundación del Software Libre&lt;/a&gt;, creó la primera versión de este sistema operativo. El papel fundamental jugado por estas herramientas libres del proyecto GNU hace que este sistema operativo sea denominado también como GNU/Linux, pero en este texto utilizaremos la denominación más sencilla y corta.&lt;/p&gt;

&lt;p&gt;El desarrollo de Linux es uno de los ejemplos más claros de desarrollo de software libre por una comunidad dispersa de programadores. Cualquiera puede usar el sistema operativo, estudiarlo y modificarlo. Estos derechos están protegidos por la licencia &lt;a href=&#34;http://es.wikipedia.org/wiki/GPL&#34; target=&#34;_blank&#34;&gt;GPL&lt;/a&gt; (GNU General Public License).&lt;/p&gt;

&lt;h2 id=&#34;distribuciones&#34;&gt;Distribuciones&lt;/h2&gt;

&lt;p&gt;Linux, como cualquier otro sistema operativo, se compone de un gran número de piezas, que, en este caso, son desarrolladas de forma independiente por miles de programadores y proyectos. Normalmente estas piezas son integradas por un distribuidor y Linux es suministrado como una &lt;a href=&#34;http://es.wikipedia.org/wiki/Distribución_linux&#34; target=&#34;_blank&#34;&gt;distribución Linux&lt;/a&gt;. Las distribuciones Linux incluyen todo el software necesario para instalar un servidor o un escritorio. Algunas de las aplicaciones comúnmente incluidas incluyen: el navegador web Firefox y las aplicaciones de oficina LibreOffice.&lt;/p&gt;

&lt;p&gt;Existen cientos de distribuciones Linux. Estas distribuciones están adaptadas para usuarios o tareas específicas. Algunas de estas distribuciones están desarrolladas o apoyadas por empresas como Fedora (Red Hat) y &lt;a href=&#34;http://www.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt; (Canonical) mientras que otras son mantenidas por la propia comunidad de usuarios como &lt;a href=&#34;http://www.debian.org/&#34; target=&#34;_blank&#34;&gt;Debian&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;software-libre&#34;&gt;Software libre&lt;/h2&gt;

&lt;p&gt;El &lt;a href=&#34;http://es.wikipedia.org/wiki/Software_libre&#34; target=&#34;_blank&#34;&gt;software libre&lt;/a&gt; es software que puede ser utilizado, estudiado, modificado, copiado y redistribuido sin restricciones. Habitualmente el software libre suele ser además gratuito, pero ese no tiene por que ser necesariamente el caso.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/gpl_logo.png&#34; alt=&#34;GPL Logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;En la práctica el software libre se distribuye junto al código fuente que lo hace posible y junto a una nota en la que se explican cuales son los derechos y las obligaciones del usuario final. Esta nota se denomina licencia. El movimiento del software libre fue iniciado por Richard Stallman en 1983. Stallman decidió crear un sistema compatible con Unix completamente libre al que llamó GNU (GNU is Not Unix). Con el tiempo este sistema acabaría uniéndose al kernel de Linus para formar un sistema operativo completo.&lt;/p&gt;

&lt;p&gt;Dado que las aplicaciones del software libre suelen ser gratuitas, su modelo de negocio suele basarse en el cobro de los servicios de soporte al usuario y de adaptación del software.&lt;/p&gt;

&lt;h1 id=&#34;introducción-a-ubuntu&#34;&gt;Introducción a Ubuntu&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://es.wikipedia.org/wiki/Ubuntu&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt; es una distribución Linux mantenida por la empresa Canonical. Está orientada a usuarios de escritorio y sus puntos fuertes son su facilidad de uso y de instalación. Aunque el escritorio es algo distinto al de Windows o Mac OS X familiarizarse con él para un usuario acostumbrado a cualquiera de los otros sistemas operativos no debería presentar muchos problemas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/ubuntu_logo.png&#34; alt=&#34;Ubuntu logo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Su instalación resulta muy sencilla. Al instalarla, una gran cantidad de software se instala de forma automática para facilitar su uso como escritorio. Ejemplos de estos programas son LibreOffice o Firefox. Además de estos programas instalados por defecto una enorme cantidad de programas se encuentra disponible para ser instalados con unos pocos clicks de ratón.&lt;/p&gt;

&lt;p&gt;Ubuntu está basada en una distribución mantenida por la comunidad de usuarios llamada &lt;a href=&#34;http://www.debian.org/&#34; target=&#34;_blank&#34;&gt;Debian&lt;/a&gt;. El principal objetivo de Debian es crear un sistema operativo robusto que incluya la mayor proporción posible de programas libres.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://bioinf.comav.upv.es/courses/unix/static/debian_logo.png&#34; alt=&#34;Debian&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Existen numerosos manuales de utilización de Ubuntu, pero algunas de las guías más completas son la &lt;a href=&#34;https://help.ubuntu.com/lts/ubuntu-help/index.html&#34; target=&#34;_blank&#34;&gt;Ubuntu Desktop Guide&lt;/a&gt; y el manual &lt;a href=&#34;http://ubuntu-manual.org/&#34; target=&#34;_blank&#34;&gt;Getting Started with Ubuntu&lt;/a&gt;. Vamos a recorrer lo principales conceptos de este sistema operativo basandonos en este &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/documentacion/Getting Started with Ubuntu 16.04.pdf&#34; target=&#34;_blank&#34;&gt;manual&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;los-usuarios&#34;&gt;Los usuarios&lt;/h2&gt;

&lt;p&gt;Los sistemas Unix son multiusuario, es decir soportan que varios usuarios los utilicen simultáneamente. Todos los usuarios, excepto uno, tienen unos privilegios bastante restringidos y no pueden modificar el sistema. De este modo unos usuarios se ven protegidos de las acciones de los otros.&lt;/p&gt;

&lt;p&gt;Existe un usuario especial llamado &lt;em&gt;root&lt;/em&gt; con privilegios de administración absolutos sobre el sistema. Para realizar las tareas cotidianas nunca hay que acceder al sistema como &lt;em&gt;root&lt;/em&gt;. En Ubuntu este usuario está deshabilitado por defecto y sólo se pueden adquirir los privilegios de administrador temporalmente.&lt;/p&gt;

&lt;h2 id=&#34;el-escritorio&#34;&gt;El escritorio&lt;/h2&gt;

&lt;p&gt;Todos las distribciones basadas en entronos graficos (GUI) suelen tener varios entornos de escritorio para eleguir. Los entornos de escritorio suelen diferir por:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;El estilo y apariencia del entorno&lt;/li&gt;
&lt;li&gt;La forma en la que los diferentes elementos se disponen en la pantalla&lt;/li&gt;
&lt;li&gt;La forma en la que el ususario navega por el escritorio&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En el caso de Ubuntu el entorno de escritorio por defecto se denomina Unity. Se caracteriza por tener dos barras, la denominada Menu Bar y el Launcher. El Menu Bar incorpora por una lado los menus de las aplicaciones que estań activas y, por otro, un area de indicadores que nos ofrecen informacion actualizada del sistema en todo momento. El Launcher es la barra vertical que facilita el acceso a las aplicaciones mas usadas y a su estado, además de a los discos montados y a la papelera. Además tenemos el selector de escritorios virtuales. En el launcher encontramos varias aplicaciones especiales:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;El menu&lt;/li&gt;
&lt;li&gt;El selector de escritorios virtuales&lt;/li&gt;
&lt;li&gt;La papelera&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los escritorios virtuales sirven para ampliar la zona de trabajo. Por defecto hay 4 escritorios virtuales que amplían nuestro monitor por cuatro.&lt;/p&gt;

&lt;h2 id=&#34;navegando-por-el-sistema-de-ficheros&#34;&gt;Navegando por el sistema de ficheros&lt;/h2&gt;

&lt;p&gt;Al sistema de ficheros se accede a traves del menu. Tenemos la posibilidad de buscar en la barra de busqueda o navegar directamente por el menu. Una vez que seleccionemos la carpeta se abrirá una ventana del navegador de ficheros con la carpeta seleccionada. Por cierto, los términos carpeta y directorio son sinónimos, al igual que fichero y archivo.&lt;/p&gt;

&lt;p&gt;Desde el launcher también podemos acceder a nuestra carpeta personal. Este directorio personal y sus subdirectorios son los únicos lugares en los que podremos almacenar nuestros archivos personales. El resto del sistema de archivos estará restringido para funciones de administración del sistema.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;p&gt;Para comprobar que no tenemos problemas de manejo del sistema vamos a realizar una serie de tareas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Explorar el escritorio abriendo programas, moviéndote entre escritorios virtuales, minimizando y maximizando las aplicaciones, etc.&lt;/li&gt;
&lt;li&gt;Navegar al directorio “Documentos” y comprobar si tenemos algún archivo guardado.&lt;/li&gt;
&lt;li&gt;Crear un subdirectorio llamado “curso” dentro del directorio “Documentos”.&lt;/li&gt;
&lt;li&gt;Crear un fichero de texto mediante el editor de textos gedit y guardarlo en el directorio que acabamos de crear.&lt;/li&gt;
&lt;li&gt;Copiar el fichero anterior al directorio personal.&lt;/li&gt;
&lt;li&gt;Eliminar el fichero original.&lt;/li&gt;
&lt;li&gt;Reinicia el sistema operativo.&lt;/li&gt;
&lt;li&gt;Bloquea la sesión de tu usuario y vuelve a entrar en ella&lt;/li&gt;
&lt;li&gt;Añade un nuevo usuario al sistema&lt;/li&gt;
&lt;li&gt;Sal de tu usuario actual y entra como el nuevo usuario&lt;/li&gt;
&lt;li&gt;Cambiar el password del nuevo usuario&lt;/li&gt;
&lt;li&gt;Configura el protector de pantalla para que se inicie a los 10 minutos de inactividad&lt;/li&gt;
&lt;li&gt;Modifica los ajustes de la aplicación terminal para que el tipo de letra tenga un tamaño de 11 puntos&lt;/li&gt;
&lt;li&gt;Ancla la aplicación terminal a la barra de aplicaciones y desancla el editor de hojas de cálculo LibreOffice&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;la-terminal-de-unix&#34;&gt;La terminal de UNIX&lt;/h1&gt;

&lt;p&gt;La &lt;a href=&#34;https://en.wikipedia.org/wiki/Command-line_interface&#34; target=&#34;_blank&#34;&gt;Shell&lt;/a&gt; (o terminal) es un interprete de comandos. Es simplemente un modo alternativo de controlar un ordenador basado en una interfaz de texto. La terminal nos permite ejecutar software escribiendo el nombre del programa que queremos ejecutar en la terminal. Podemos pedirle al ordenador que ejecute un programa mediante el ratón ciclando en distintos lugares del escritorio o podemos escribir una orden para conseguir el mismo objetivo. Por ejemplo, para pedirle al ordenador que nos de una lista de los archivos presentes en un directorio podemos abrir un navegador de archivos o podemos escribir en la terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls folder_name
file_1.txt
file_2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ninguna de las dos formas de comunicarse con el ordenador es mejor que la otra aunque en ciertas ocasiones puede resultar más conveniente utilizar una u otra Las ventajas de la línea de comandos son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Necesidad. Existe mucho software que está sólo disponible en la terminal. Esto es especialmente cierto en el área de la bioinformática.&lt;/li&gt;
&lt;li&gt;Flexibilidad. Los programas gráficos suelen ser muy adecuados para realizar la tarea para la que han sido creados, pero son difíciles de adaptar para otras tareas. Los programas diseñados para ser usados en la línea de comandos suelen ser muy versátiles.&lt;/li&gt;
&lt;li&gt;Reproducibilidad. Documentar y repetir el proceso seguido para realizar un análisis con un programa gráfico es muy costoso puesto que es difícil describir la secuencia de clicks y doble clicks que hemos realizado. Por el contrario, los procesos realizados mediante la línea de comandos son muy fáciles de documentar puesto que tan sólo debemos guardar el texto que hemos introducido en la pantalla.&lt;/li&gt;
&lt;li&gt;Fiabilidad. Los programas básicos de Unix fueron creados en los años 70 y han sido probados por innumerables usuarios por lo que se han convertido en piezas de código extraordinariamente confiables.&lt;/li&gt;
&lt;li&gt;Recursos. Las interfaces gráficas suelen consumir muchos recursos mientras que los programas que funcionan en línea de comandos suelen ser extraordinariamente livianos y rápidos. Este poco uso de recursos facilita, por ejemplo, que se utilice a través de la red.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El problema de la terminal es que para poder utilizarla debemos saber previamente qué queremos hacer y cómo. Es habitual descubrir como funciona un programa con una interfaz gráfica sin tener que leer un manual, esto no sucede en la terminal.&lt;/p&gt;

&lt;p&gt;Para usar la línea de comandos hay que abrir una terminal. Se abrirá una terminal con un mensaje similar a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usuario $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este pequeño mensaje se denomina &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Command-line_interface#Command_prompt&#34; target=&#34;_blank&#34;&gt;prompt&lt;/a&gt;&lt;/em&gt; y el cursor parpadeante que aparece junto al él indica que el ordenador está esperando una orden. El mensaje exacto que aparece en el &lt;em&gt;prompt&lt;/em&gt; puede variar ligeramente, pero en Ubuntu suele ser similar a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usuario@ordenador:~/documentos$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En el &lt;em&gt;prompt&lt;/em&gt; de Ubuntu se nos muestra el nombre del usuario, el nombre del ordenador y el directorio en el que nos encontramos actualmente, es decir, el directorio de trabajo actual.&lt;/p&gt;

&lt;p&gt;Cuando el &lt;em&gt;prompt&lt;/em&gt; se muestra podemos ejecutar cualquier cosa, por ejemplo le podemos pedir que liste los ficheros mediante el comando &lt;em&gt;ls&lt;/em&gt; (LiSt)::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usuario $ ls
lista_libros.txt
rectas_cocina/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;ls&lt;/em&gt;, como cualquier otro comando, es en realidad un programa que el ordenador ejecuta. Cuando escribimos la orden (y pulsamos enter) el programa se ejecuta. Mientras el programa está ejecutándose el &lt;em&gt;prompt&lt;/em&gt; desaparece y no podemos ejecutar ningún otro comando. Pasado el tiempo el programa termina su ejecución y el &lt;em&gt;prompt&lt;/em&gt; vuelve a aparecer. En el caso del comando &lt;em&gt;ls&lt;/em&gt; el tiempo de ejecución es tan pequeño que suele ser imperceptible.&lt;/p&gt;

&lt;p&gt;Los programas suelen tener unas entradas y unas salidas. Dependiendo del caso estas pueden ser ficheros o caracteres introducidos o impresos en la pantalla. Por ejemplo, el resultado de &lt;em&gt;ls&lt;/em&gt; es simplemente una lista impresa de ficheros y directorios en la interfaz de comandos.&lt;/p&gt;

&lt;p&gt;Normalmente el comportamiento de los programas puede ser modificado pasándoles parámetros. Por ejemplo, podríamos pedirle al programa &lt;em&gt;ls&lt;/em&gt; que nos imprima una lista de ficheros más detallada escribiendo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ayuda&#34;&gt;Ayuda&lt;/h2&gt;

&lt;p&gt;Cada comando tiene unos parámetros y opciones distintos. La forma estándar de pedirles que nos enseñen cuales son estos parámetros suele ser utilizar las opciones ‘–help’, ‘-h’ o ‘-help’, aunque esto puede variar en comandos no estándar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls --help
Modo de empleo: ls [OPCIÓN]... [FICHERO]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otro modo de acceder a una documentación más detallada es acceder al manual del programa utilizando el comando &lt;em&gt;man&lt;/em&gt; (MANual):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ man ls
(para terminar pulsar &amp;quot;q&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;man&lt;/em&gt; es un programa interactivo, cuando ejecutamos el comando el programa se abre y el &lt;em&gt;prompt&lt;/em&gt; desaparece. &lt;em&gt;man&lt;/em&gt; es en realidad un visor de ficheros de texto por lo que cuando lo ejecutamos la pantalla se rellena con la ayuda del programa que hemos solicitado. Podemos ir hacia abajo o hacia arriba y podemos buscar en el contenido de la ayuda. El &lt;em&gt;prompt&lt;/em&gt; y la posibilidad de ejecutar otro programa no volverán a aparecer hasta que no cerremos el programa interactivo. En el caso de man para cerrar el programa hay que pulsar la tecla “q”.&lt;/p&gt;

&lt;h2 id=&#34;completado-automático-e-historia&#34;&gt;Completado automático e historia&lt;/h2&gt;

&lt;p&gt;El intérprete de comandos dispone de algunas utilidades para facilitarnos su uso. Una de las más utilizadas es el completado automático. Podemos evitarnos escribir una gran parte de los comandos haciendo uso de la tecla tabulador. Si empezamos a escribir un comando y pulsamos la tecla tabulador el sistema completará el comando por nosotros. Para probarlo creemos los ficheros datos_1.txt, datos_2.txt y tesis.txt::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ touch datos_1.txt
~$ touch datos_2.txt
~$ touch experimento.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si ahora empezamos a escribir &lt;em&gt;cp e&lt;/em&gt; y pulsamos el tabulador dos veces, el intérprete de comandos completará el comando automáticamente::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp e
~$ cp experimento.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si el intérprete encuentra varias alternativas completará el comando hasta el punto en el que no haya ambigüedad. Si deseamos que imprima una lista de todas las alternativas disponibles para continuar con el comando deberemos pulsar el tabulador dos veces.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp d
$ cp datos_
datos_1.txt  datos_2.txt
~$ cp datos_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otra de las funcionalidades que más nos pueden ayudar es la historia. El intérprete recuerda todos los comandos que hemos introducido anteriormente. Si queremos podemos obtener una lista de todo lo que hemos ejecutado utilizando el comando history. Pero lo más socorrido es simplemente utilizar los cursores arriba y abajo para revisar los comandos anteriores. Otra forma de acceder a la historia es utilizar la combinación de teclas control y r. De este modo podemos buscar comandos antiguos sencillamente.&lt;/p&gt;

&lt;h2 id=&#34;ejercicio&#34;&gt;Ejercicio&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Lista todos los comandos que empiezan por apt&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bibliografía&#34;&gt;Bibliografía&lt;/h1&gt;

&lt;p&gt;Existen numerosas fuentes sobre la historia y la filosofía de Unix, de Linux y del software libre. Entre ellas se encuentran:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Las páginas de la wikipedia sobre: &lt;a href=&#34;http://es.wikipedia.org/wiki/Unix&#34; target=&#34;_blank&#34;&gt;Unix&lt;/a&gt;, &lt;a href=&#34;http://es.wikipedia.org/wiki/Linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;, &lt;a href=&#34;http://es.wikipedia.org/wiki/Ubuntu&#34; target=&#34;_blank&#34;&gt;Ubuntu&lt;/a&gt; y [software libre](&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/&#34; target=&#34;_blank&#34;&gt;https://bioinf.comav.upv.es/courses/unix/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Rebel-Code-Linux-Source-Revolution/dp/0738203335&#34; target=&#34;_blank&#34;&gt;Rebel Code&lt;/a&gt;, un libro de Glyn Moody dedicado a la historia del movimiento del software libre.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oreilly.com/catalog/9780596001087&#34; target=&#34;_blank&#34;&gt;La catedral y el bazar&lt;/a&gt; de Eric S. Raymond. Un ensayo sobre los beneficios del modelo de desarrollo asociados al software libre.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://catb.org/~esr/writings/taoup/&#34; target=&#34;_blank&#34;&gt;The Art of Unix Programming&lt;/a&gt; (&lt;a href=&#34;https://bioinf.comav.upv.es/documentacion/bibliography/the_art_of_unix_programming.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt; de Eric S. Raymond. Dedicado a la filosofía de los sistemas Unix.&lt;/li&gt;
&lt;li&gt;El excelente [Ubuntu manual](&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/&#34; target=&#34;_blank&#34;&gt;https://bioinf.comav.upv.es/courses/unix/&lt;/a&gt; [pdf](&lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/&#34; target=&#34;_blank&#34;&gt;https://bioinf.comav.upv.es/courses/unix/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;La documentación &lt;a href=&#34;https://help.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;oficial&lt;/a&gt; y de la &lt;a href=&#34;https://help.ubuntu.com/community&#34; target=&#34;_blank&#34;&gt;comunidad&lt;/a&gt; de Ubuntu.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hay varios cursos para iniciarse en el uso de la línea de comandos de Unix, como:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.flossmanuals.net/gnulinux&#34; target=&#34;_blank&#34;&gt;Put Yourself in Command&lt;/a&gt; de la Free Software Fundation, copia en &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/documentacion/fsf_cmd_manual.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxcommand.org/learning_the_shell.php&#34; target=&#34;_blank&#34;&gt;Learning the shell&lt;/a&gt; de &lt;a href=&#34;http://linuxcommand.org/lc3_learning_the_shell.php&#34; target=&#34;_blank&#34;&gt;Linuxcommand.org&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rlworkman.net/howtos/rute/&#34; target=&#34;_blank&#34;&gt;Rute User’s Tutorial and Exposition&lt;/a&gt; de Paul Sheer, copia en &lt;a href=&#34;https://bioinf.comav.upv.es/courses/unix/documentacion/rute.pdf&#34; target=&#34;_blank&#34;&gt;pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://oreilly.com/catalog/9780596002619&#34; target=&#34;_blank&#34;&gt;Learning the Unix Operating System&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Sistema de ficheros</title>
      <link>https://www.marcusrb.com/unix/02-sistema-ficheros/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://www.marcusrb.com/unix/02-sistema-ficheros/</guid>
      <description>

&lt;p&gt;El &lt;a href=&#34;https://en.wikipedia.org/wiki/File_system&#34; target=&#34;_blank&#34;&gt;sistema de archivos&lt;/a&gt; controla como se almacenan los archivos en el ordenador. Sus dos tareas principales son guardar y leer archivos previamente guardados.&lt;/p&gt;

&lt;h2 id=&#34;sistemas-jerárquicos&#34;&gt;Sistemas jerárquicos&lt;/h2&gt;

&lt;p&gt;Los sistemas de archivos suelen tener &lt;a href=&#34;https://en.wikipedia.org/wiki/Directory_(computing)&#34; target=&#34;_blank&#34;&gt;directorios&lt;/a&gt; en los que organizar los archivos y estos directorios suelen estar organizados jerárquicamente. La jerarquía implica que un directorio puede contener subdirectorios. El directorio más alto en la jerarquía del que cuelgan todos los demás se denomina &lt;em&gt;raíz&lt;/em&gt; (root). En los sistemas Unix el directorio raíz se representa con una barra “*/*” y sólo existe una jerarquía, es decir, sólo existe un directorio raíz, incluso aunque haya distintos discos duros en el ordenador.&lt;/p&gt;

&lt;p&gt;Dentro del directorio raíz podemos encontrar diversos subdirectorios, por ejemplo en Linux existe el directorio &lt;em&gt;home&lt;/em&gt;. &lt;em&gt;home&lt;/em&gt; es por tanto un subdictorio del directorio raíz. Esta relación se representa como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;home&lt;/em&gt; es el directorio dónde se encuentran los directorios de los usuarios en un sistema Linux. Imaginemos que tiene los subdirectorios &lt;em&gt;alicia&lt;/em&gt; y &lt;em&gt;juan&lt;/em&gt;. Se representaría como:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia
/home/juan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Existe un estándar, denominado &lt;a href=&#34;https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard&#34; target=&#34;_blank&#34;&gt;Filesystem Hierarchy Standard&lt;/a&gt; que define la estructura de directorios de los sistemas Unix. Los sistemas Unix suelen seguir este estándar, aunque a veces lo violan en algunos aspectos. Por ejemplo en MacOS X el directorio donde se encuentran los direcotorios de los usuarios se denomina &lt;em&gt;Users&lt;/em&gt; y no &lt;em&gt;home&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;En algunos sistemas operativos no UNIX la barra se escribe al revés “&amp;rdquo;, a pesar de que la convención siempre fue la contraria.&lt;/p&gt;

&lt;p&gt;En el directorio raíz hay diversos directorios que, en la mayoría de los casos, sólo deberían interesarnos si estamos administrando el ordenador. Los usuarios normalmente sólo escriben dentro de un directorio de su propiedad localizado dentro de /home y denominado como su nombre de usuario.&lt;/p&gt;

&lt;p&gt;Los usuarios también pueden escribir en /tmp aunque normalmente son los procesos lanzados por estos lo que hacen esta escritura. Es importante revisar el espacio libre en la partición en la que se encuentra /tmp para que no se colapse el sistema. Recuerda que /tmp es borrado habitualmente por el sistema. Normalmente con cada nuevo arranque.&lt;/p&gt;

&lt;h2 id=&#34;rutas-absolutas-relativas-y-directorio-de-trabajo&#34;&gt;Rutas absolutas, relativas y directorio de trabajo&lt;/h2&gt;

&lt;p&gt;Para referirnos a un archivo o a un directorio debemos indicar su ruta (&lt;a href=&#34;https://en.wikipedia.org/wiki/Path_(computing)&#34; target=&#34;_blank&#34;&gt;path&lt;/a&gt;. Un ejemplo de ruta podría ser:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia/documentos/tesis.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este tipo de rutas en las que se especifican todos los subdirectorios empezando desde el directorio raíz se denominan rutas absolutas.&lt;/p&gt;

&lt;p&gt;Para no tener que escribir la ruta absoluta completa cada vez que queremos referirnos a un archivo o a un directorio se crearon los conceptos de &lt;a href=&#34;https://en.wikipedia.org/wiki/Working_directory&#34; target=&#34;_blank&#34;&gt;directorio de trabajo&lt;/a&gt; y de &lt;a href=&#34;https://en.wikipedia.org/wiki/Path_(computing)#Absolute_and_relative_paths&#34; target=&#34;_blank&#34;&gt;ruta relativa&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;El directorio de trabajo es una propiedad del terminal (del shell) en la que estamos trabajando. Siempre que estemos trabajando en una terminal tendremos asignado un directorio de trabajo. Por ejemplo, si nuestro usuario es &lt;em&gt;alicia&lt;/em&gt; sería normal que al abrir un terminal nuestro directorio de trabajo fuese:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El directorio de trabajo se utiliza para escribir rutas a archivos relativas al mismo. De este modo nos ahorramos escribir bastante. Imaginemos que Alicia tiene en su directorio un documento llamado peliculas.txt. La ruta absoluta sería.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/home/alicia/peliculas.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mientras su directorio de trabajo sea /home/alicia la ruta relativa sería simplemetne:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;peliculas.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es decir, podemos escribir rutas relativas al directorio de trabajo, rutas que en vez de partir del directorio raíz parten desde el directorio de trabajo. Las rutas relativas se diferencian de las absolutas en los sistemas Unix porque las absolutas empiezan por “y” las relativas no.&lt;/p&gt;

&lt;p&gt;Es común referirse al directorio de trabajo de una terminal como a un lugar en el que nos encontramos mientras estamos trabajando en la terminal. Siempre que estemos en una terminal estaremos dentro de un directorio de trabajo.&lt;/p&gt;

&lt;p&gt;Por ejemplo, cuando abrimos un nuevo terminal el directorio de trabajo se sitúa en /home/nombre_de_usuario. Si ejecutamos el comando &lt;em&gt;ls&lt;/em&gt;, el programa asumirá que queremos listar los archivos presentes en ese directorio y no en otro cualquiera. Existe un comando que nos informa sobre el directorio de trabajo actual, pwd (Print Working Directory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pwd
/home/alicia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si deseamos podemos modificar el directorio de trabajo “moviéndonos” a otro directorio. Para lograrlo hay que utilizar el comando &lt;em&gt;cd&lt;/em&gt; (Change Directory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd documentos
$ pwd
/home/alicia/documentos
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A partir de ese momento los comandos asumirán que si no se les indica lo contrario el directorio desde el que deben trabajar es /home/alicia/documentos.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;cd&lt;/em&gt; además tiene algunos parámetros especiales:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd      Ir al directorio $HOME del usuario.
cd -    Ir al directorio de trabajo previo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;directorio-home&#34;&gt;Directorio $HOME&lt;/h2&gt;

&lt;p&gt;El directorio $HOME en los sistemas Unix, que son sistemas multiusuario, es el directorio en el que el usuario debe mantener sus ficheros y directorios. Fuera de este directorio el usuario tendrá unos permisos restringidos puesto que sus acciones podrían afectar a otros usuarios.&lt;/p&gt;

&lt;p&gt;En Linux los directorios $HOME de los usuarios son subdirectorios del directorio &lt;em&gt;/home&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El directorio $HOME de un usuario es además el directorio de trabajo por defecto, es decir, el directorio de trabajo que se establece cuando se abre una terminal.&lt;/p&gt;

&lt;h2 id=&#34;moviendo-renombrando-y-copiando-ficheros&#34;&gt;Moviendo, renombrando y copiando ficheros&lt;/h2&gt;

&lt;p&gt;En primer lugar vamos a crear un fichero de prueba:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ touch data.txt
~$ ls
data.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El comando &lt;em&gt;touch&lt;/em&gt;, en este caso, ha creado un fichero vacío.&lt;/p&gt;

&lt;p&gt;Los ficheros se copian con el comando &lt;em&gt;cp&lt;/em&gt; (CoPy):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp data.txt data.bak.txt
~$ ls
data.bak.txt  data.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se mueven y renombran con el &lt;em&gt;mv&lt;/em&gt; (MoVe):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mv data.txt experimento_1.txt
~$ ls
data.bak.txt  experimento_1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para crear un nuevo directorio podemos utilizar la orden &lt;em&gt;mkdir&lt;/em&gt; (MaKeDIRectory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mkdir exp_1
~$ ls
data.bak.txt  exp_1  experimento_1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;mv&lt;/em&gt; también sirve para mover ficheros entre directorios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mv experimento_1.txt exp_1/
~$ ls
data.bak.txt  exp_1
~$ ls exp_1/
experimento_1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Los ficheros se eliminan con la orden &lt;em&gt;rm&lt;/em&gt; (ReMove):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ rm data.bak.txt
~$ ls
exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En la línea de comandos de los sistemas Unix cuando se borra un fichero se borra definitivamente, no hay papelera. Una vez ejecutado el &lt;em&gt;rm&lt;/em&gt; no podremos recuperar el archivo.&lt;/p&gt;

&lt;p&gt;Los comandos &lt;em&gt;cp&lt;/em&gt; y &lt;em&gt;rm&lt;/em&gt; no funcionarán bien con los directorios a no ser que modifiquemos el comportamiento que muestran por defecto:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ rm exp_1/
rm: cannot remove exp_1/ Is a directory
~$ cp exp_1/ exp_1_bak/
cp: omitting directory exp_1/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esto sucede porque para copiar o borrar un directorio hay que copiar o borrar todos sus contenidos recursivamente y esto podría alterar muchos datos con un sólo comando. Por esta razón se exige que estos dos comandos incluyan un modificador que les indique que sí deben funcionar recursivamente cuando tratan con directorios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ cp -r exp_1/ exp_1_bak/
~$ ls
exp_1  exp_1_bak
~$ rm -r exp_1_bak/
~$ ls
exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nombres-de-directorios-y-archivos&#34;&gt;Nombres de directorios y archivos&lt;/h2&gt;

&lt;p&gt;En Unix los archivos pueden tener prácticamente cualquier nombre. Existe la convención de acabar los nombres con un punto y una pequeña extensión que indica el tipo de archivo. Pero esto es sólo una convención, en realidad podríamos no utilizar este tipo de nomenclatura.&lt;/p&gt;

&lt;p&gt;Si deseamos utilizar nombres de archivos que no vayan a causar extraños comportamientos en el futuro lo mejor sería seguir unas cuantas reglas al nombrar un archivo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Añadir una extensión para recordarnos el tipo de archivo, por ejemplo .txt para los archivos de texto.&lt;/li&gt;
&lt;li&gt;No utilizar en los nombres:

&lt;ul&gt;
&lt;li&gt;espacios,&lt;/li&gt;
&lt;li&gt;caracteres no alfanuméricos,&lt;/li&gt;
&lt;li&gt;ni caracteres no ingleses como letras acentuadas o eñes.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por supuesto, podríamos crear un archivo denominado “$ñ 1.txt” para referirnos a un archivo de sonido, pero esto conllevaría una sería de problemas que aunque son solventables nos dificultarán el trabajo.&lt;/p&gt;

&lt;p&gt;Además es importante recordar que en Unix las mayúsculas y las minúsculas no son lo mismo. Los ficheros “documento.txt”, “Documento.txt” y “DOCUMENTO.TXT” son tres ficheros distintos.&lt;/p&gt;

&lt;p&gt;Otra convención utilizada en los sistema Unix es la de ocultar los archivos cuyos nombres comienzan por punto “.”. Por ejemplo el archivo “.oculto” no aparecerá normalmente cuando pedimos el listado de un directorio. Esto se utiliza normalmente para guardar archivos de configuración que no suelen ser utilizados directamente por los usuarios. Para listar todos los archivos (All), ya sean éstos ocultos o no se puede ejecutar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -a
.               .fontconfig          .HyperTree           .pki
..               fsm.jpg              .ICEauthority        .recently-used
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta convención de ocultar los ficheros cuyo nombre comienza por un punto se mantiene también en el navegador gráfico de ficheros. En este caso podemos pedir que se muestren estos archivos en el menú Ver -&amp;gt; Mostrar los archivos ocultos.&lt;/p&gt;

&lt;p&gt;Para acelerar el acceso a ciertos directorios existen algunos nombres especiales que son bastante útiles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* &amp;quot;..&amp;quot; indica el directorio padre del directorio actual
* &amp;quot;.&amp;quot; indica el directorio actual
* &amp;quot;~&amp;quot; representa la $HOME del usuario
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wildcards&#34;&gt;WildCards&lt;/h2&gt;

&lt;p&gt;En muchas ocasiones resulta útil tratar los ficheros de un modo conjunto. Por ejemplo, imaginemos que queremos mover todos los ficheros de texto a un directorio y la imágenes a otro. Creemos una pequeña demostración::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ touch exp_1a.txt
~$ touch exp_1b.txt
~$ touch exp_1b.jpg
~$ touch exp_1a.jpg
~$ ls
exp_1  exp_1a.jpg  exp_1a.txt  exp_1b.jpg  exp_1b.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos referirnos a todos los archivos que acaban en txt utilizando un asterisco:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ mv *txt exp_1
~$ ls
exp_1  exp_1a.jpg  exp_1b.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El asterisco sustituye a cualquier texto, por lo que al escribir *txt incluimos a cualquier fichero que tenga un nombre cualquiera, pero que termine con las letras txt. Podríamos por ejemplo referirnos a los ficheros del experimento 1a:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls *1a*
exp_1a.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta herramienta es muy potente y útil, pero tenemos que tener cuidado con ella, sobre todo cuando la combinamos con &lt;em&gt;rm&lt;/em&gt;. Por ejemplo la orden:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -r *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Borraría todos los ficheros y directorios que se encuentren bajo el directorio de trabajo actual, si lo hacemos perderemos todos los ficheros y directorios que cuelgan del actual directorio de trabajo, puede que esto sea lo que queramos, pero hemos de andar con cuidado.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;¿Cuáles son los ficheros y directorios presentes en el directorio raíz?&lt;/li&gt;
&lt;li&gt;¿Cuáles son todos los archivos presentes en nuestro directorio de usuario?&lt;/li&gt;
&lt;li&gt;Crea un directorio llamado experimento.&lt;/li&gt;
&lt;li&gt;Crea con touch los archivos datos1.txt y datos2.txt dentro del directorio experimento.&lt;/li&gt;
&lt;li&gt;Vuelve al directorio principal de tu usuario y desde allí lista los archivos presentes en el directorio experimento usando rutas absolutas y relativas&lt;/li&gt;
&lt;li&gt;Haz del directorio ~/Documentos tu directorio de trabajo y repite el ejercicio anterior&lt;/li&gt;
&lt;li&gt;Borra todos los archivos que contengan un 2 en el directorio experimento.&lt;/li&gt;
&lt;li&gt;Copia el directorio experimento a un nuevo directorio llamado exp_seguridad.&lt;/li&gt;
&lt;li&gt;Borra el directorio experimento.&lt;/li&gt;
&lt;li&gt;Renombra el directorio exp_seguridad a experimento.&lt;/li&gt;
&lt;li&gt;Copia el fichero /etc/passwd al directorio ~/Documentos&lt;/li&gt;
&lt;li&gt;Copia el fichero /etc/passwd al directorio ~/Documentos llamándolo usuarios.txt&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;obteniendo-información-sobre-archivos-y-directorios&#34;&gt;Obteniendo información sobre archivos y directorios&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;ls&lt;/em&gt; es un comando capaz de mostrarnos información extra sobre los archivos y directorios que lista. Por ejemplo podemos pedirle, usando la opción &lt;em&gt;-l&lt;/em&gt; (Long), que nos muestre quién es el dueño del archivo y cuanto ocupa y qué permisos tiene además de otras cosas::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls
exp_1
~$ ls -l
total 4
drwxr-xr-x 2 usuario usuario 4096 Oct 13 09:48 exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La información sobre la cantidad de disco ocupada la da por defecto en bytes, si la queremos en un formato más inteligible podemos utilizar la opción &lt;em&gt;-h&lt;/em&gt; (Human):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls -lh
total 4.0K
drwxr-xr-x 2 usuario usuario 4.0K Oct 13 09:48 exp_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos consultar el tipo de un archivo mediante el comando &lt;em&gt;file&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ file imagen.png
imagen.png: PNG image data, 1920 x 1080, 8-bit/color RGB, non-interlaced
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En principio, el tipo de un archivo no está determinado por la extensión, la extensión es sólo parte del nombre, aunque hay software que viola o complementa este principio. El tipo de archivo está determinado por su &lt;a href=&#34;https://en.wikipedia.org/wiki/Magic_number_(programming)&#34; target=&#34;_blank&#34;&gt;magic number&lt;/a&gt;. El magic number está compuesto por una corta &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_file_signatures&#34; target=&#34;_blank&#34;&gt;serie de bytes&lt;/a&gt; que indican el tipo de archivo.&lt;/p&gt;

&lt;h2 id=&#34;permisos&#34;&gt;Permisos&lt;/h2&gt;

&lt;p&gt;Unix desde su origen ha sido un sistema multiusuario. Para conseguir que cada usuario pueda trabajar en sus archivos, pero que no pueda interferir accidental o deliberadamente con los archivos de otros usuarios se estableció desde el principio un sistema de permisos. Por defecto un usuario tiene permiso para leer y modificar sus propios archivos y directorios, pero no los de los demás. En los sistemas Unix los ficheros pertenecen a un usuario concreto y existen unos permisos diferenciados para este usuario y para el resto. Además el usuario pertenece a un grupo de trabajo. Por ejemplo, imaginemos que la usuaria alicia puede pertenecer al grupo de trabajo “diagnostico”. Si alicia crea un fichero este tendrá unos permisos diferentes para alicia, para el resto de miembros de su grupo y para el resto de usuarios del ordenador. Podemos ver los permisos asociados a los ficheros utilizando el comando &lt;em&gt;ls&lt;/em&gt; con la opción -l (Long)::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~$ ls -l
total 7324
-rw-r--r-- 1 alicia diagnostico    1059 Oct 20 12:42 busqueda_leukemia_100.txt
-rw-r--r-- 1 alicia diagnostico       0 Oct 13 10:53 datos_1.txt
drwxr-xr-x 2 alicia diagnostico    4096 Oct 13 10:29 experimento
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En este caso, los ficheros listados pertenecen Alicia y al grupo diagnostico. Los permisos asignados al usuario, a los miembros del grupo y al resto de usuarios están resumidos en la primeras letras de cada línea::&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-x---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La primera letra indica el tipo de fichero listado: (d) directorio, (-) fichero u otro tipo especial. Las siguientes nueve letras muestran, en grupos de tres, los permisos para el usuario, para el grupo y para el resto de usuarios del ordenador. Cada grupo de tres letras indica los permisos de lectura (Read), escritura (Write) y ejecución (eXecute). En el caso anterior el usuario tiene permiso de lectura, escritura y ejecución (rwx), el grupo tiene permiso de lectura y ejecución (r-x), es decir no puede modificar el fichero o el directorio, y el resto de usuarios no tienen ningún permiso (—).&lt;/p&gt;

&lt;p&gt;En los ficheros normales el permiso de lectura indica si el fichero puede ser leído, el de escritura si puede ser modificado y el de ejecución si puede ser ejecutado. En el caso de los directorios el de escritura indica si podemos añadir o borrar ficheros del directorio y el de ejecución si podemos listar los contenidos del directorio.&lt;/p&gt;

&lt;p&gt;Estos permisos pueden ser modificados con la orden &lt;em&gt;chmod&lt;/em&gt;. En chmod cada grupo de usuarios se representa por una letra:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;u: usuario dueño del fichero&lt;/li&gt;
&lt;li&gt;g: grupo de usuarios del dueño del fichero&lt;/li&gt;
&lt;li&gt;o: todos los otros usuarios&lt;/li&gt;
&lt;li&gt;a: todos los tipos de usuario (dueño, grupo y otros)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Los tipos de permisos también están abreviados por letras:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;r: lectura&lt;/li&gt;
&lt;li&gt;w: escritura&lt;/li&gt;
&lt;li&gt;x: ejecución&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con estas abreviaturas podemos modificar los permisos existentes.&lt;/p&gt;

&lt;p&gt;Hacer un fichero ejecutable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod u+x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a+x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos mediante chmod indicar los permisos para un tipo de usuario determinado.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a=rwx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un modo algo menos intuitivo, pero más útil de utilizar chmod es mediante los números octales que representan los permisos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- lectura: 4
- escritura: 2
- ejecución: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para modificar los permisos de este modo debemos indicar el número octal que queremos que represente los permisos del fichero. La primera cifra representará al dueño, la segunda al grupo y la tercera al resto de usuarios. Por ejemplo si queremos que único permiso para el dueño y su grupo sea la lectura y que no haya ningún permiso para el resto de usuarios:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 110 fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos combinar permisos sumando los números anteriores. Por ejemplo, permiso para leer y escribir para el dueño y ningún permiso para el resto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 300 fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Permisos de lectura, escritura y ejecución para el dueño y su grupo y ninguno para el resto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 770 fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las restricciones para los permisos no afectan al usuario root, al administrador del sistema. root también puede modificar quien el dueño y el grupo al que pertenecen los ficheros mediante los comando chown y chgrp.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chown alicia fichero.txt
$ chown diagnostico fichero.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;obteniendo-información-sobre-el-sistema-de-archivos&#34;&gt;Obteniendo información sobre el sistema de archivos&lt;/h2&gt;

&lt;p&gt;El sistema de archivos puede abarcar una o más &lt;a href=&#34;https://en.wikipedia.org/wiki/Disk_partitioning&#34; target=&#34;_blank&#34;&gt;particiones&lt;/a&gt;. Una partición es una región de un disco o de cualquier otro medio de almacenamiento. Las instalaciones de Windows tienen normalmente una partición por disco, pero en Linux esto no es tan habitual. Cada partición tiene un sistema de archivos propio, pero en Unix estos sistemas deben estar montados en algún lugar dentro de la jerarquía que cuelga de la raíz. En Windows cada partición tiene por defecto una jerarquía independiente.&lt;/p&gt;

&lt;p&gt;Podemos pedir información sobre el espacio ocupado por las distintas particiones que tenemos actualmente montadas usando el comando &lt;em&gt;df&lt;/em&gt; (Disk Free).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ df -h
S.ficheros     Tamaño Usados  Disp Uso% Montado en
udev             7,8G      0  7,8G   0% /dev
tmpfs            1,6G   9,8M  1,6G   1% /run
/dev/nvme0n1p2    25G   8,1G   16G  35% /
tmpfs            7,8G   5,3M  7,8G   1% /dev/shm
tmpfs            5,0M   4,0K  5,0M   1% /run/lock
tmpfs            7,8G      0  7,8G   0% /sys/fs/cgroup
/dev/nvme0n1p4   206G    18G  178G   9% /home
/dev/nvme0n1p1   511M   3,6M  508M   1% /boot/efi
/dev/sda1        2,7T   117G  2,5T   5% /home/jose/magnet
tmpfs            1,6G    64K  1,6G   1% /run/user/1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Algunos de los sistemas de archivos montados puede que no se correspondan con particiones en un disco físico sino con espacios de la memoria RAM que son utilizados como sistemas de archivos especiales.&lt;/p&gt;

&lt;p&gt;El commando &lt;em&gt;du&lt;/em&gt; (disk usage) informa sobre el espacio que ocupa un árbol de directorios. Este comando tiene equivalentes gráficos como Baobab o xdiskusage. Podemos pedir a &lt;em&gt;du&lt;/em&gt; que nos muestre cuanto espacio ocupan los directorios bajo el directorio analysis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -h analyses/
36K	analyses/alicia/cache
204K	analyses/alicia/differential_snps/differential
252K	analyses/alicia/differential_snps/non_differentia
919M	analyses/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si sólo queremos obtener el resultado para el directorio que le hemos dado y no para sus subdirectorios podemos utilizar el parámetro &lt;em&gt;-s&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -sh analyses/
919M	analyses/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si queremos información sobre todos los archivos y no sólo los directorios podemos usar &lt;em&gt;-a&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ du -ha analyses/
32K	analyses/alicia/cache/min_called_rate_samples_cache.pickle
36K	analyses/alicia/cache
8,0K	analyses/alicia/look_for_matching_accessions.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ejercicios-1&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;¿Cuáles son los permisos de los directorios presentes en el directorio raíz y en nuestro directorio de usuario? ¿A quién pertenecen los ficheros y qué permisos tienen los distintos usuarios del ordenador?&lt;/li&gt;
&lt;li&gt;Crea un directorio en tu home y muestra los permisos que tiene.&lt;/li&gt;
&lt;li&gt;Cambia los permisos para que sólo tu usuario pueda acceder al nuevo directorio&lt;/li&gt;
&lt;li&gt;Crea un fichero nuevo y dale permisos de ejecución para todos los usuarios&lt;/li&gt;
&lt;li&gt;Último fichero modificado en el directorio /etc.&lt;/li&gt;
&lt;li&gt;Lista los ficheros de /etc con su tamaño y ordénalos por tamaño.&lt;/li&gt;
&lt;li&gt;Copia todos los ficheros y directorios del directorio /etc cuyo nombre comience por s. ¿Has podido copiarlos todos?&lt;/li&gt;
&lt;li&gt;¿Cuánto espacio libre queda en las distintas particiones del sistema?&lt;/li&gt;
&lt;li&gt;¿Cuánto espacio ocupan todos los ficheros y subdirectorios de tu $HOME?&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;compresion-y-descompresión-de-ficheros&#34;&gt;Compresion y descompresión de ficheros&lt;/h2&gt;

&lt;p&gt;Existen distintos formatos de compresión de ficheros como: gzip, bzip, zip o rar. Los formatos más utilizados en Unix son gzip y bzip.&lt;/p&gt;

&lt;p&gt;Comprimir un fichero con gzip o bzip:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gzip informacion_snps.txt
$ ls
informacion_snps.txt.gz

$ bzip2 accs.txt
$ ls
accs.txt.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bzip2 comprime más que gzip, pero es más lento. gzip también dispone de varios niveles de compresión, cuanto más comprime más lenta suele ser la compresión.&lt;/p&gt;

&lt;p&gt;Podemos descomprimir cualquier fichero utilizando la línea de comandos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gunzip informacion_snps.txt.gz
$ ls
informacion_snps.txt
$ bunzip2 accs.txt.bz2
$ ls
accs.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Muchos estamos acostumbrados al formato zip. Un fichero zip no se corresponde en realidad con un sólo fichero comprimido sino con varios. Un fichero zip hace dos cosas: unir varios ficheros en uno y comprimir el resultado. Los comandos que hemos visto (gzip y bzip2) son capaces de comprimir un sólo archivo, pero no pueden unir varios archivos en uno. &lt;em&gt;tar&lt;/em&gt; es el comando capaz de unir varios archivos en uno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
seq1.fasta  seq2.fasta
$ tar -cvf secuencias.tar seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;tar&lt;/em&gt; también es capaz de desempaquetar los archivos que habíamos unido.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
secuencias.tar
$ rm seq1.fasta seq2.fasta
$ tar -xvf secuencias.tar
seq1.fasta
seq2.fasta
$ ls
secuencias.tar  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El problema es que utilizando el comando &lt;em&gt;tar&lt;/em&gt; tal y como lo hemos hecho hemos conseguido unir y separar archivos, pero no hemos comprimido el fichero unido. Para hacerlo podríamos utilizar los comandos &lt;em&gt;gzip&lt;/em&gt; o &lt;em&gt;bzip2&lt;/em&gt;, pero este no es el modo habitula de hacerlo. Dado que casi siempre que unamos archivos en un archivo tar también querremos comprimir el resultado el comando tar tiene también la capacidad de comprimir y descomprimir utilizando los algoritmos gzip y bzip2. Unir y comprimir con gzip varios archivos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -cvzf secuencias.tar.gz seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.gz  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Descomprimir un archivo tar.gz:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -xvzf secuencias.tar.gz
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.gz  seq1.fasta  seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También podemos descomprimir el contenido de un fichero de texto y enviar el resultado a la terminal con el comando &lt;em&gt;zcat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;$ zcat fichero.txt.gz&lt;/p&gt;

&lt;p&gt;Con bzip2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -cvjf secuencias.tar.bz seq*
seq1.fasta
seq2.fasta
$ ls
secuencias.tar.bz  seq1.fasta  seq2.fasta

$ tar -xvjf secuencias.tar.bz
seq1.fasta
seq2.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ejercicios-2&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Crea un fichero de texto en el directorio ~/Documentos y comprimelo con gzip&lt;/li&gt;
&lt;li&gt;Muestra el contenido del fichero anterior en pantalla sin descomprimirlo previamente&lt;/li&gt;
&lt;li&gt;Crea un archivo tar de todo el contenido del directorio ~/Documentos&lt;/li&gt;
&lt;li&gt;Comprime el fichero tar anterior&lt;/li&gt;
&lt;li&gt;Vuelve a hacer los ejercicios 2 y 3, pero en un sólo paso&lt;/li&gt;
&lt;li&gt;Descomprime el fichero tar.gz anterior en un nuevo directorio llamado Documentos2&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;enlaces-duros-y-blandos&#34;&gt;Enlaces duros y blandos&lt;/h2&gt;

&lt;p&gt;Podemos pensar en el nombre de un fichero como en una etiqueta que apunta a una posición concreta en el disco duro, en realidad es un puntero a un &lt;a href=&#34;https://en.wikipedia.org/wiki/Inode&#34; target=&#34;_blank&#34;&gt;inodo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Podmeos pensar en un &lt;a href=&#34;https://en.wikipedia.org/wiki/Hard_link&#34; target=&#34;_blank&#34;&gt;enlace duro&lt;/a&gt; como en un nombre adicional para un archivo. Si tenemos un archivo en el disco y creamos un enlace duro tendremos dos nombres para ese único archivo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
archivo1.txt
$ ln archivo1.txt nombre2.txt
$ ls
archivo1.txt nombre2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Las dos referencias, nombres, al archivo serán indistinguibles. Si borramos un nombre quedará el otro. Si modificamos un archivo se modifica independientemente del nombre por el cual estemos accediendo a él. No es muy común utilizar enlaces duro salvo en aplicaciones muy concretas, por ejemplo en versiones de copias de seguridad.&lt;/p&gt;

&lt;p&gt;Un enlace blando, más comumente conocido como un enlace simbólico, es una referencia al nombre de un archivo, no al archivo en sí.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
archivo1.txt
$ ln -s archivo1.txt nombre3.txt
$ ls -l
-rw-rw-r-- 1 jose jose  0 sep 27 15:16 archivo1.txt
lrwxrwxrwx 1 jose jose 12 sep 27 15:16 nombre3.txt -&amp;gt; archivo1.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si eliminamos el archivo original el enlace quedará roto.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm archivo1.txt
$ cat nombre3.txt
cat: nombre3.txt: No existe el archivo o el directorio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El comportamiento de ambos tipos de enlaces cambia si sobreescribimos el fichero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x
$ echo &amp;quot;hola&amp;quot; &amp;gt; hola.txt
$ cat hola.txt
hola
$ ln hola.txt hola2.txt
$ ln -s hola.txt hola3.txt
$ ls -l
-rw-rw-r-- 2 jose jose 5 sep 27 15:23 hola2.txt
lrwxrwxrwx 1 jose jose 8 sep 27 15:25 hola3.txt -&amp;gt; hola.txt
-rw-rw-r-- 2 jose jose 5 sep 27 15:23 hola.txt
$ echo &amp;quot;adios&amp;quot; &amp;gt; adios.txt
$ mv adios.txt hola.txt
$ cat hola.txt
adios
$ cat hola2.txt
hola
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Los enlaces blandos funcionan incluso entre distintos sistemas de archivos o particiones, los duros no.&lt;/p&gt;

&lt;h2 id=&#34;ejercicios-3&#34;&gt;Ejercicios&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Crea un enlace simbólico a un fichero de texto dentro del direcotorio ~/Documentos&lt;/li&gt;
&lt;li&gt;Crea un enlace duro al mismo fichero.&lt;/li&gt;
&lt;li&gt;Edita el fichero de texto y observa como cambian ambos enlaces&lt;/li&gt;
&lt;li&gt;Crea un nuevo fichero de texto con otro contenido. Sustituye el primer fichero con el segundo y observa el resultado en ambos enlaces&lt;/li&gt;
&lt;li&gt;Crea dos enlaces, uno simbólico y otro duro, a un fichero. Elimina el fichero y observa el resultado en ambos enlaces&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;acceso-remoto&#34;&gt;Acceso remoto&lt;/h2&gt;

&lt;p&gt;Una de las grandes ventajas de utilizar la terminal es que podemos acceder a terminales en otros ordenadores muy fácilmente. El protocolo más utilizado para acceder a terminales de forma remota es &lt;a href=&#34;https://en.wikipedia.org/wiki/Secure_Shell&#34; target=&#34;_blank&#34;&gt;ssh&lt;/a&gt; (Secure Shell). ssh tiene un gran número de posibilidades, pero el uso más habitual es utilizarlo para abrir terminales en ordenadores remotos que tienen un servicio ssh. ssh es seguro porque cifra las comunicaciones entre el cliente y el servidor. ssh se diseñó como una alternativa segura a telnet. No debemos usar el protocolo telnet porque las comunicaciones en telnet, incluidas las claves de acceso, no están cifradas y cualquiera puede tener acceso a ellas.&lt;/p&gt;

&lt;p&gt;Para acceder a una computadora que implemente el protocolo ssh podemos usar el programa ssh, pero previamente tenemos que tener una cuenta en esa computadora. Imaginemos que alicia tiene una cuenta en un ordenador que tiene un servicio ssh. Para conectarse puede hacer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh alicia@ordenador.upv.es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si el nombre de la cuenta de usuario en el ordenador cliente y en el servidor es el mismo puede obviar el nombre de usuario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ordenador.upv.es
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A continuación el servidor le pedirá la clave correspondiente a ese usuario.&lt;/p&gt;

&lt;p&gt;Existen clientes ssh para windows con los que nos podemos conectar a servidores ssh. Uno muy común es &lt;a href=&#34;http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html&#34; target=&#34;_blank&#34;&gt;putty&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una tarea muy habitual cuando estamos trabajando en un ordenador remoto es enviar o traer ficheros desde el mismo. Esto también lo podemos hacer utilizando el protocolo ssh por lo que podremos hacerlo de un modo seguro en cualquier ordenador que no de acceso ssh. El programa más sencillo para hacerlo desde Unix es &lt;a href=&#34;https://en.wikipedia.org/wiki/Secure_copy&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;scp&lt;/em&gt;&lt;/a&gt; (Secure CoPy). &lt;em&gt;scp&lt;/em&gt; tiene una interfaz muy similar a &lt;em&gt;cp&lt;/em&gt; pero acepta que los ficheros de origen y destino estén en distintos ordenadores:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scp alicia@remotehost.edu:/remote/directory/seq.txt /some/local/directory
$ scp /some/local/directory/seq.txt alicia@remotehost.edu:/remote/directory/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En windows también hay distintos clientes scp, uno de ellos es &lt;a href=&#34;https://winscp.net/eng/download.php&#34; target=&#34;_blank&#34;&gt;winscp&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una alternativa a scp que tiene más capacidades, como enviar fragmentos de ficheros, es &lt;a href=&#34;https://en.wikipedia.org/wiki/Rsync&#34; target=&#34;_blank&#34;&gt;rsync&lt;/a&gt;. &lt;em&gt;rsync&lt;/em&gt; está diseñado para mantener varios archivos sincronizados entre dos ordenadores, pero también ser puede utilizar para copiar archivos de un ordenador a otro como scp. &lt;em&gt;rsync&lt;/em&gt; puede establecer la conexión utilizando distintos protocolos, pero uno de ellos es ssh por lo que funcionará también con cualquier servidor ssh.&lt;/p&gt;

&lt;p&gt;Si lo que queremos es descargar un fichero desde un servidor en internet, por ejemplo desde una página web, al ordenador remoto en el que estamos trabajando en una sesión ssh podemos utilizar el comando &lt;em&gt;wget&lt;/em&gt; o su alternativa &lt;em&gt;curl&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget https://http://ncbi.nlm.nih.gov/una_secuencia.fasta
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ejercicios-4&#34;&gt;Ejercicios&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Contectate a un servidor remoto usando ssh&lt;/li&gt;
&lt;li&gt;Transfiere un fichero desde tu ordenador al servidor&lt;/li&gt;
&lt;li&gt;Descarga el fichero &lt;a href=&#34;https://www.gnu.org/licenses/gpl.txt&#34; target=&#34;_blank&#34;&gt;https://www.gnu.org/licenses/gpl.txt&lt;/a&gt; directamente en el ordenador remoto&lt;/li&gt;
&lt;li&gt;Copia el fichero gpl.txt a tu ordenador&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
